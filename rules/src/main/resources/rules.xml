<?xml version="1.0" encoding="UTF-8"?>
<root>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-port"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify server port configuration in Spring Boot applications.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>port</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-port-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Server port configuration found"
                          category-id="information"
                          effort="0">
                        <message>
                            The application is setting the server port. To migrate a Java application that sets the server port to Azure Spring Apps:

                            * **Be aware of potential port reliance issues**: Azure Spring Apps overwrites the server.port setting in the deployed application. If any clients of the clients rely on the application being available on a port other than 443, you will need to modify them.
                        </message>
                        <link title="Identify any clients relying on a non-standard port"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#identify-any-clients-relying-on-a-non-standard-port"/>
                        <tag>server port</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="(^|\s)server\.port"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-schedule-job"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Determine whether application relies on scheduled jobs.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>scheduler</tag>
            <tag>quartz</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-schedule-job-01000">
                <when>
                    <or>
                        <project>
                            <artifact groupId="org.quartz-scheduler" artifactId="{*}"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.boot"
                                      artifactId="spring-boot-starter-quartz"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="The application uses Quartz to scheduled jobs"
                          category-id="mandatory"
                          effort="7">
                        <message>
                            The application uses Quartz scheduled jobs. Scheduled jobs, such as Quartz Scheduler tasks or Unix cron jobs can't be used with cloud service like Azure App Service, Azure Spring Apps, Azure Kubernetes Service.
                            These Azure services won't prevent you from deploying an application containing scheduled tasks internally.
                            However, if your application is scaled out, the same scheduled job may run more than once per scheduled period.
                            This situation can lead to unintended consequences.

                            To migrate a Java application that uses scheduled jobs to Azure, you can follow these recommendations:

                            * **Identify scheduled jobs**: Inventory any scheduled tasks running on the production server(s), inside or outside your application code. Search the application code for references to Quartz, @Scheduled annotation, or cron expressions.

                            * **Remove scheduled jobs**: Remove the scheduled jobs. If you need to run scheduled jobs, you can use Azure Container Apps jobs. Azure Container Apps jobs allow you to run containerized tasks that execute for a finite duration and exit. You can trigger a job manually, schedule their execution, or trigger their execution based on events.
                        </message>
                        <link title="The application uses Quartz to scheduled jobs"
                              href="https://docs.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-app-service#determine-whether-application-relies-on-scheduled-jobs"/>
                        <link title="Jobs in Azure Container Apps"
                              href="https://learn.microsoft.com/azure/container-apps/jobs"/>
                        <link title="Create a job with Azure Container Apps"
                              href="https://learn.microsoft.com/azure/container-apps/jobs-get-started-cli"/>
                        <tag>quartz</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-eureka"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify eureka dependencies.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>eureka</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-eureka-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Explicit eureka connection info found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a Eureka connection string.

                            If you are migrating to Azure Spring Apps, the connection info of Config Server will be injected upon app start.
                            Find any explicit configurations of Eureka connection info and remove them:

                            If configured in **configuration files**: they will be ignored and overrided by Azure Spring Apps.

                            If configured in **command line parameters**, **Java system attribute**, **environment variable**: they need to be removed or you might experience conflicts and unexpected behavior.
                        </message>
                        <link title="Azure Spring Apps - Enable Service Registration"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-service-registration?pivots=programming-language-java"/>
                        <link title="Azure Spring Apps - Access Config Server and Service Registry"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-access-data-plane-azure-ad-rbac"/>
                        <link title="Restricted configurations"
                              href="http://aka.ms/spring-cloud-to-asa?pivots=sc-standard-tier#remove-restricted-configurations"/>
                        <tag>eureka</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Eureka</technology-tag>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="eureka\.client\.(service-url|serviceUrl)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-config-server"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset identifies Spring Cloud config server configurations in Spring Boot applications.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>Spring Cloud Config</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-config-server-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Explicit Config Server connection info found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a Spring Cloud Config Server connection string.

                            If you are migrating to Azure Spring Apps, the connection info of Config Server will be injected automatically upon app start.
                            Find any explicit configurations of config server connection info:

                            If configured in **configuration files**: they will be ignored and overrided by Azure Spring Apps.

                            If configured in **command line parameters**, **Java system attribute**, **environment variable**: they need to be removed or you might experience conflicts and unexpected behavior.

                            Configure the config server after creating an Azure Spring Apps instance.
                        </message>
                        <link title="Remove restricted configurations"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#remove-restricted-configurations"/>
                        <link title="Prepare the Spring Cloud Config server"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#prepare-the-spring-cloud-config-server"/>
                        <tag>Spring Cloud Config</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Spring Cloud Config</technology-tag>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="spring\.config\.import|spring\.cloud\.config\.uri"/>
                </where>
            </rule>
            <rule id="spring-boot-to-azure-config-server-02000">
                <when>
                    <or>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-config-server"/>
                        </project>
                        <javaclass references="org.springframework.cloud.config.server.EnableConfigServer.EnableConfigServer">
                            <location>IMPORT</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="Spring Cloud Config Server found"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses Spring Cloud Config Server.

                            If you are migrating to Azure Spring Apps, Config Server (Standard Tier) or Application Configuration Service (Enterprise Tier) will be hosted for you.
                            You can just configure the config server after creating an Azure Spring Apps instance
                        </message>
                        <link title="Prepare the Spring Cloud Config server"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#prepare-the-spring-cloud-config-server"/>
                        <tag>Spring Cloud Config</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Spring Cloud Config</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Determine whether application relies on Spring Cloud Config Server</name>

        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-config-server</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>not-tested</groupId>
                <artifactId>spring-cloud-config-server</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>not-tested</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
        </dependencies>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring cloud open source support version</name>

        <properties>
            <java.version>1.8</java.version>
            <spring-cloud.version>finchley</spring-cloud.version>
        </properties>

        <dependencyManagement>
            <dependencies>
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring cloud open source support version</name>

        <properties>
            <java.version>1.8</java.version>
            <spring-cloud.version>2021.0.3</spring-cloud.version>
        </properties>

        <dependencyManagement>
            <dependencies>
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring cloud open source support version</name>

        <properties>
            <java.version>1.8</java.version>
            <spring-cloud.version>2020.0.3</spring-cloud.version>
        </properties>

        <dependencyManagement>
            <dependencies>
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring cloud open source support version</name>

        <properties>
            <java.version>1.8</java.version>
            <spring-cloud.version>hoxton</spring-cloud.version>
        </properties>

        <dependencyManagement>
            <dependencies>
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-cloud-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring cloud open source support version</name>

        <properties>
            <java.version>1.8</java.version>
            <spring-cloud.version>Edgware</spring-cloud.version>
        </properties>

        <dependencyManagement>
            <dependencies>
                <dependency>
                    <groupId>org.springframework.cloud</groupId>
                    <artifactId>spring-cloud-dependencies</artifactId>
                    <version>${spring-cloud.version}</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>
            </dependencies>
        </dependencyManagement>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.7.10</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.6.13</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.0.0</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>3.0.5</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>1.5.19.RELEASE</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.5</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.4.13</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-version</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Recommend Spring Boot open source support version</name>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.5.14</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-eureka</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Identify Eureka dependencies</name>

        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-netflix-eureka-something</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-netflix-eureka-something</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>not-tested</groupId>
                <artifactId>spring-cloud-starter-netflix-eureka-something</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>com.netflix.eureka</groupId>
                <artifactId>eureka-client</artifactId>
                <version>5.0.10.Final</version>
                <scope>runtime</scope>
            </dependency>
            <dependency>
                <groupId>not-tested</groupId>
                <artifactId>eureka-client</artifactId>
                <version>5.0.10.Final</version>
                <scope>runtime</scope>
            </dependency>
        </dependencies>
    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>spring-boot-to-azure-schedule-job</artifactId>
        <version>4.2.1_SNAPSHOT</version>
        <name>Determine whether application relies on scheduled jobs.</name>

        <dependencies>
            <dependency>
                <groupId>org.quartz-scheduler</groupId>
                <artifactId>should-be-tested-one</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>org.quartz-scheduler</groupId>
                <artifactId>should-be-tested-two</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-quartz</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>not-tested</groupId>
                <artifactId>spring-boot-starter-quartz</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>not-tested</artifactId>
                <version>5.0.10.Final</version>
            </dependency>
        </dependencies>
    </project>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-spring-boot-version"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Recommend Spring Boot open source support version
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>version</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-spring-boot-version-01000">
                <when>
                    <project>
                        <artifact groupId="org.springframework.boot"
                                  artifactId="{*}"
                                  fromVersion="1"
                                  toVersion="1.9"/>
                    </project>
                </when>
                <perform>
                    <hint title="Spring Boot version too low"
                          category-id="potential"
                          effort="5">
                        <message>
                            The application is using Spring Boot 1.x, which is too low. With the officially supported new versions from Spring, you can get the best experience.

                            Here are some steps you can take to update your application to a supported version of Spring Boot:

                            * Choose a **supported Spring Boot version**: Check out Spring Boot Support Versions, determine the most suitable supported Spring Boot version.

                            * **Update Spring Boot version**: Update the Spring Boot version of your application. There are automated tools like Rewrite to help you with the migration.

                            * **Address code compatibility**: Review your application's codebase for any potential compatibility issues with the target Spring Boot version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                            * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Spring Boot version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.
                        </message>
                        <link title="Azure Spring Apps Spring Boot Version Support"
                              href="https://learn.microsoft.com/azure/spring-apps/concept-app-customer-responsibilities#spring-boot-and-spring-cloud-versions"/>
                        <link title="Spring Boot Supported Versions"
                              href="https://spring.io/projects/spring-boot#support"/>
                        <link title="Spring Boot Support Policy"
                              href="https://github.com/spring-projects/spring-boot/wiki/Supported-Versions"/>
                        <link title="Use Rewrite to migrate to Spring Boot 2 from Spring Boot 1"
                              href="https://docs.openrewrite.org/running-recipes/popular-recipe-guides/spring-boot-2.x-migration-from-spring-boot-1.x"/>
                    </hint>
                </perform>
            </rule>
            <rule id="spring-boot-to-azure-spring-boot-version-02000">
                <when>
                    <project>
                        <artifact groupId="org.springframework.boot"
                                  artifactId="{*}"
                                  fromVersion="2"
                                  toVersion="2.5.99"/>
                    </project>
                </when>
                <perform>
                    <hint title="Spring Boot version out of support"
                          category-id="information"
                          effort="2">
                        <message>
                            The application is using Spring Boot version lower than 2.6, which is out of support. With the officially supported new versions from Spring, you can get the best experience.

                            Here are some steps you can take to update your application to a supported version of Spring Boot:

                            * Choose a **supported Spring Boot version**: Check out Spring Boot Support Versions, determine the most suitable supported Spring Boot version.

                            * **Update Spring Boot version**: Update the Spring Boot version of your application. There are automated tools like Rewrite to help you with the migration.

                            * **Address code compatibility**: Review your application's codebase for any potential compatibility issues with the target Spring Boot version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                            * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Spring Boot version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.
                        </message>
                        <link title="Azure Spring Apps Spring Boot Version Support"
                              href="https://learn.microsoft.com/azure/spring-apps/concept-app-customer-responsibilities#spring-boot-and-spring-cloud-versions"/>
                        <link title="Spring Boot Supported Versions"
                              href="https://spring.io/projects/spring-boot#support"/>
                        <link title="Spring Boot Support Policy"
                              href="https://github.com/spring-projects/spring-boot/wiki/Supported-Versions"/>
                        <link title="Use Rewrite to migrate to Spring Boot 3 from Spring Boot 2"
                              href="https://docs.openrewrite.org/running-recipes/popular-recipe-guides/migrate-to-spring-3"/>
                    </hint>
                </perform>
            </rule>
            <rule id="spring-boot-to-azure-spring-boot-version-03000">
                <when>
                    <project>
                        <artifact groupId="org.springframework.boot"
                                  artifactId="{*}"
                                  fromVersion="2.6"
                                  toVersion="2.6.99"/>
                    </project>
                </when>
                <perform>
                    <hint title="Spring Boot version out of OSS support"
                          category-id="information"
                          effort="1">
                        <message>
                            The application is using Spring Boot version out of Open Source Software support. It's recommended to update your plan to commercial support or update the application to open source support version of Spring Boot.

                            For commercial support:

                            * Migrate to **Azure Spring App Enterprise plan**: The Enterprise plan provides extended commercial support for Spring Boot/Spring Cloud. This support gives you access to Spring experts, enabling you to unlock the full potential of the Spring ecosystem to develop and deploy applications faster with Long-Term Support (LTS).

                            For Spring Boot update, here are some steps you can take:

                            * Choose a **supported Spring Boot version**: Check out Spring Boot Support Versions, determine the most suitable supported Spring Boot version.

                            * **Update Spring Boot version**: Update the Spring Boot version of your application. There are automated tools like Rewrite to help you with the migration.

                            * **Address code compatibility**: Review your application's codebase for any potential compatibility issues with the target Spring Boot version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                            * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Spring Boot version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.
                        </message>
                        <link title="Azure Spring Apps Spring Boot Version Support"
                              href="https://learn.microsoft.com/azure/spring-apps/concept-app-customer-responsibilities#spring-boot-and-spring-cloud-versions"/>
                        <link title="Azure Spring App Enterprise plan: Unlock Spring’s full potential with Long-Term Support (LTS)"
                              href="https://learn.microsoft.com/azure/spring-apps/overview#unlock-springs-full-potential-with-long-term-support-lts"/>
                        <link title="Spring Boot Supported Versions"
                              href="https://spring.io/projects/spring-boot#support"/>
                        <link title="Spring Boot Support Policy"
                              href="https://github.com/spring-projects/spring-boot/wiki/Supported-Versions"/>
                        <link title="Use Rewrite to migrate to Spring Boot 3 from Spring Boot 2"
                              href="https://docs.openrewrite.org/running-recipes/popular-recipe-guides/migrate-to-spring-3"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-restricted-config"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset identifies restricted configurations in Spring Boot applications for migration to Azure Spring Apps.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-restricted-config-01000">
                <when>
                    <or>
                        <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                    </or>
                </when>
                <perform>
                    <hint title="Restricted configurations found"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses restricted configurations for Azure Spring Apps.
                            These properties are automatically injected into your application environment by Azure Spring Apps to access Config Server and Service Discovery.
                            Please remove them from your application, including configuration files, config server files, command line parameters, Java system attributes, and environment variables.

                            If configured in **configuration files**: they will be ignored and overrided by Azure Spring Apps.

                            If configured in **Config Server files**, **command line parameters**, **Java system attribute**, **environment variable**: they need to be removed or you might experience conflicts and unexpected behavior.
                        </message>
                        <link title="Remove restricted configurations"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?toc=%2Fazure%2Fspring-apps%2Ftoc.json&amp;bc=%2Fazure%2Fspring-apps%2Fbreadcrumb%2Ftoc.json&amp;pivots=sc-standard-tier#remove-restricted-configurations"/>
                        <link title="Set up a Config server"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-config-server"/>
                        <link title="Enable Service Registration"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-service-registration?pivots=programming-language-java"/>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="(eureka\.client\.(serviceUrl\.defaultZone|service-url\.defaultZone))|(eureka\.client\.tls\.keystore)|(eureka\.instance\.preferIpAddress)|(eureka\.instance\.instance-id)|(server\.port)|(spring\.cloud\.config\.tls\.keystore)|(spring\.config\.import)|(spring\.application\.name)|(spring\.jmx\.enabled)|(management\.endpoints\.jmx\.exposure\.include)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="spring-boot-to-azure-spring-cloud-version"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Recommend Spring cloud open source support version
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>version</tag>
        </metadata>
        <rules>
            <rule id="spring-boot-to-azure-spring-cloud-version-01000">
                <when>
                    <project>
                        <artifact groupId="org.springframework.cloud"
                                  artifactId="spring-cloud-dependencies"
                                  fromVersion="Angel"
                                  toVersion="Edgware.9"/>
                    </project>
                </when>
                <perform>
                    <hint title="Spring Cloud version too low"
                          category-id="potential"
                          effort="5">
                        <message>
                            The application is using a Spring Cloud version that is too low. To get the best experience, consider upgrading to a supported version of Spring Cloud.

                            Here are some steps you can take:

                            * Choose a **supported Spring Cloud version**: Check out the Spring Cloud Supported Versions page to determine the most suitable supported version.

                            * **Update Spring Cloud version**: Update the Spring Cloud version of your application. There are automated tools like Rewrite to help you with the migration.

                            * **Address code compatibility**: Review your application's codebase for any potential compatibility issues with the target Spring Cloud version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                            * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Spring Cloud version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.
                        </message>
                        <link title="Azure Spring Apps Spring Boot Version Support"
                              href="https://learn.microsoft.com/azure/spring-apps/concept-app-customer-responsibilities#spring-boot-and-spring-cloud-versions"/>
                        <link title="Spring Cloud" href="https://spring.io/projects/spring-cloud"/>
                        <link title="Spring Cloud Supported Versions"
                              href="https://github.com/spring-cloud/spring-cloud-release/wiki/Supported-Versions"/>
                        <link title="Use Rewrite to migrate to Spring Cloud 2022"
                              href="https://docs.openrewrite.org/recipes/java/spring/cloud2022/upgradespringcloud_2022"/>
                    </hint>
                </perform>
            </rule>
            <rule id="spring-boot-to-azure-spring-cloud-version-02000">
                <when>
                    <project>
                        <artifact groupId="org.springframework.cloud"
                                  artifactId="spring-cloud-dependencies"
                                  fromVersion="Finchley"
                                  toVersion="2020.99"/>
                    </project>
                </when>
                <perform>
                    <hint title="spring cloud version out of support"
                          category-id="information"
                          effort="2">
                        <message>
                            The application is using a Spring Cloud version that is no longer supported. To get the best experience, consider upgrading to a supported version of Spring Cloud.

                            Here are some steps you can take to update your application to a supported version of Spring Cloud:

                            * Choose a **supported Spring Cloud version**: Check out the Spring Cloud Supported Versions page to determine the most suitable supported version.

                            * **Update Spring Cloud version**: Update the Spring Cloud version of your application. There are automated tools like Rewrite to help you with the migration.

                            * **Address code compatibility**: Review your application's codebase for any potential compatibility issues with the target Spring Cloud version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                            * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Spring Cloud version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.
                        </message>
                        <link title="Azure Spring Apps Spring Boot Version Support"
                              href="https://learn.microsoft.com/azure/spring-apps/concept-app-customer-responsibilities#spring-boot-and-spring-cloud-versions"/>
                        <link title="Spring Cloud" href="https://spring.io/projects/spring-cloud"/>
                        <link title="Spring Cloud Supported Versions"
                              href="https://github.com/spring-cloud/spring-cloud-release/wiki/Supported-Versions"/>
                        <link title="Use Rewrite to migrate to Spring Cloud 2022"
                              href="https://docs.openrewrite.org/recipes/java/spring/cloud2022/upgradespringcloud_2022"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <datasources>
        <xa-datasource jndi-name="java:/MSSQLXADS" pool-name="MSSQLXADS">
            <driver>sqlserver</driver>
            <xa-datasource-property name="ServerName">localhost</xa-datasource-property>
            <xa-datasource-property name="DatabaseName">mssqldb</xa-datasource-property>
            <xa-datasource-property name="SelectMethod">cursor</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <xa-pool>
                <is-same-rm-override>false</is-same-rm-override>
            </xa-pool>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLValidConnectionChecker"/>
            </validation>
        </xa-datasource>
        <drivers>
            <driver name="sqlserver" module="com.microsoft">
                <xa-datasource-class>com.microsoft.sqlserver.jdbc.SQLServerXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <xa-datasource jndi-name="java:/DB2XADS" pool-name="DB2XADS">
            <driver>ibmdb2</driver>
            <xa-datasource-property name="DatabaseName">ibmdb2db</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <xa-pool>
                <is-same-rm-override>false</is-same-rm-override>
            </xa-pool>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2ValidConnectionChecker"/>
                <stale-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2StaleConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2ExceptionSorter"/>
            </validation>
            <recovery>
                <recovery-plugin class-name="org.jboss.jca.core.recovery.ConfigurableRecoveryPlugin">
                    <config-property name="EnableIsValid">false</config-property>
                    <config-property name="IsValidOverride">false</config-property>
                    <config-property name="EnableClose">false</config-property>
                </recovery-plugin>
            </recovery>
        </xa-datasource>
        <drivers>
            <driver name="ibmdb2" module="com.ibm">
                <xa-datasource-class>com.ibm.db2.jcc.DB2XADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <datasource jndi-name="java:/OracleDS" pool-name="OracleDS">
            <connection-url>jdbc:oracle:thin:@localhost:1521:XE</connection-url>
            <driver>oracle</driver>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker"/>
                <stale-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleStaleConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter"/>
            </validation>
        </datasource>
        <drivers>
            <driver name="oracle" module="com.oracle">
                <xa-datasource-class>oracle.jdbc.xa.client.OracleXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <xa-datasource jndi-name="java:jboss/MysqlXADS" pool-name="MysqlXADS">
            <driver>mysql</driver>
            <xa-datasource-property name="ServerName">localhost</xa-datasource-property>
            <xa-datasource-property name="DatabaseName">mysqldb</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter"/>
            </validation>
        </xa-datasource>
        <drivers>
            <driver name="mysql" module="com.mysql">
                <xa-datasource-class>com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <datasource jndi-name="java:jboss/datasources/postgresDS"
                    pool-name="postgres-pool"
                    enabled="true"
                    use-java-context="true">
            <connection-url>jdbc:postgresql://db:5432/postgres</connection-url>
            <driver>postgres</driver>
            <security>
                <user-name>application</user-name>
                <password>s3cr3t</password>
            </security>
        </datasource>
    </datasources>
    <datasources>
        <datasource jndi-name="java:/DB2DS" pool-name="DB2DS">
            <connection-url>jdbc:db2:ibmdb2db</connection-url>
            <driver>ibmdb2</driver>
            <pool>
                <min-pool-size>0</min-pool-size>
                <max-pool-size>50</max-pool-size>
            </pool>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2ValidConnectionChecker"/>
                <stale-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2StaleConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.db2.DB2ExceptionSorter"/>
            </validation>
        </datasource>
        <drivers>
            <driver name="ibmdb2" module="com.ibm">
                <xa-datasource-class>com.ibm.db2.jdbc.DB2XADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <xa-datasource jndi-name="java:/XAOracleDS" pool-name="XAOracleDS">
            <driver>oracle</driver>
            <xa-datasource-property name="URL">jdbc:oracle:oci8:@tc</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <xa-pool>
                <is-same-rm-override>false</is-same-rm-override>
                <no-tx-separate-pools/>
            </xa-pool>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker"/>
                <stale-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleStaleConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter"/>
            </validation>
        </xa-datasource>
        <drivers>
            <driver name="oracle" module="com.oracle">
                <xa-datasource-class>oracle.jdbc.xa.client.OracleXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <datasource jndi-name="java:jboss/MySqlDS" pool-name="MySqlDS">
            <connection-url>jdbc:mysql://mysql-localhost:3306/jbossdb</connection-url>
            <driver>mysql</driver>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter"/>
            </validation>
        </datasource>
        <drivers>
            <driver name="mysql" module="com.mysql">
                <xa-datasource-class>com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <xa-datasource jndi-name="java:jboss/SybaseXADS"
                       pool-name="SybaseXADS"
                       enabled="true">
            <xa-datasource-property name="NetworkProtocol">Tds</xa-datasource-property>
            <xa-datasource-property name="ServerName">myserver</xa-datasource-property>
            <xa-datasource-property name="PortNumber">4100</xa-datasource-property>
            <xa-datasource-property name="DatabaseName">mydatabase</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseValidConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseExceptionSorter"/>
            </validation>
        </xa-datasource>
        <drivers>
            <driver name="sybase" module="com.sybase">
                <datasource-class>com.sybase.jdbc2.jdbc.SybDataSource</datasource-class>
                <xa-datasource-class>com.sybase.jdbc3.jdbc.SybXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <datasource jndi-name="java:/MSSQLDS" pool-name="MSSQLDS">
            <connection-url>jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=MyDatabase</connection-url>
            <driver>sqlserver</driver>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.mssql.MSSQLValidConnectionChecker"/>
            </validation>
        </datasource>
        <drivers>
            <driver name="sqlserver" module="com.microsoft">
                <xa-datasource-class>com.microsoft.sqlserver.jdbc.SQLServerXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <datasource jndi-name="java:jboss/SybaseDB" pool-name="SybaseDB" enabled="true">
            <connection-url>jdbc:sybase:Tds:localhost:5000/DATABASE?JCONNECT_VERSION=6</connection-url>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseValidConnectionChecker"/>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.sybase.SybaseExceptionSorter"/>
            </validation>
        </datasource>
        <drivers>
            <driver name="sybase" module="com.sybase">
                <datasource-class>com.sybase.jdbc2.jdbc.SybDataSource</datasource-class>
                <xa-datasource-class>com.sybase.jdbc3.jdbc.SybXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <datasources>
        <xa-datasource jndi-name="java:jboss/PostgresXADS" pool-name="PostgresXADS">
            <driver>postgresql</driver>
            <xa-datasource-property name="ServerName">localhost</xa-datasource-property>
            <xa-datasource-property name="PortNumber">5432</xa-datasource-property>
            <xa-datasource-property name="DatabaseName">postgresdb</xa-datasource-property>
            <security>
                <user-name>admin</user-name>
                <password>admin</password>
            </security>
            <validation>
                <valid-connection-checker class-name="org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker">
                </valid-connection-checker>
                <exception-sorter class-name="org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter">
                </exception-sorter>
            </validation>
        </xa-datasource>
        <drivers>
            <driver name="postgresql" module="org.postgresql">
                <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>
            </driver>
        </drivers>
    </datasources>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.jboss.windup.rules.test</groupId>
        <artifactId>eap-to-azure-appservice-pom</artifactId>
        <version>1.0.0-SNAPSHOT</version>
        <name>EapToAzureAppService</name>

        <dependencies>
            <dependency>
                <groupId>org.jboss.bom</groupId>
                <artifactId>eap-runtime-artifacts</artifactId>
                <version>7.3.0.Final</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </project>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="eap-to-azure-appservice-pom"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Show how to deploy an application to JBoss on App Service
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="eap" versionRange="[7,8)"/>
            <targetTechnology id="azure-appservice"/>
            <tag>Azure</tag>
        </metadata>
        <rules>
            <rule id="eap-to-azure-appservice-pom-001">
                <when>
                    <project>
                        <artifact groupId="org.jboss.bom"
                                  artifactId="eap-runtime-artifacts"
                                  fromVersion="7.3.0.Final"/>
                    </project>
                </when>
                <perform>
                    <hint title="Get started with JBoss EAP on App Service"
                          category-id="optional"
                          effort="1">
                        <message>
                            Get started with JBoss EAP on App Service with the CLI commands below. Don't have the Azure CLI installed? Go to [https://aka.ms/azure-cli](https://aka.ms/azure-cli)

                            ```
                            # Customize these variables
                            $resourceGroup=jboss-rg
                            $location=eastus
                            $appName=jboss-app
                            $appServicePlan=jboss-asp

                            az group create --resource-group $resourceGroup --location $location

                            az appservice plan create --resource-group $resourceGroup --name $appServicePlan --is-linux --sku P1V3

                            az webapp create --resource-group $resourceGroup --name $appName --plan $appServicePlan --runtime "JBOSSEAP|7.3-java8"

                            # Build your app with:
                            mvn package

                            # Run one of the following commands depending on the artifact type

                            # To deploy WAR files:
                            az webapp deploy --resource-group $resourceGroup --plan $appServicePlan --name $appName --type war --src-path app.war

                            # To deploy EAR files:
                            az webapp deploy --resource-group $resourceGroup --plan $appServicePlan --name $appName --type ear --src-path app.ear
                            ```
                        </message>
                        <link title="Get the Azure CLI" href="https://aka.ms/azure-cli"/>
                        <link title="Configure a Java app for Azure App Service - Deploying your app"
                              href="https://aka.ms/webapps-deployment-apis"/>
                        <link title="Migrate JBoss EAP applications to JBoss EAP on Azure App Service"
                              href="https://aka.ms/webapps-jboss-migrate-guide"/>

                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="eap-to-azure-appservice-datasource-driver"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                External resources such as data sources are injected via Java Naming and Directory Interface (JNDI). Some such resources may require migration or reconfiguration.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="eap" versionRange="[7,8)"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <tag>password</tag>
            <tag>security</tag>
        </metadata>
        <rules>
            <rule id="eap-to-azure-appservice-datasource-driver-01000">
                <when>
                    <or>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:db2')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'db2')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:mysql')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'mysql')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:oracle')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'oracle')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:postgres')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'postgres')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:microsoft:sqlserver')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'sqlserver')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/datasource/connection-url[contains(text(),'jdbc:sybase')]"
                                 in="{*}-ds.xml"/>
                        <xmlfile matches="/datasources/drivers/driver/xa-datasource-class[contains(text(),'sybase')]"
                                 in="{*}-ds.xml"/>
                    </or>
                </when>
                <perform>
                    <hint title="Datasource driver found in configuration file"
                          category-id="potential"
                          effort="3">
                        <message>
                            A datasource driver was found in a configuration file.

                            There are three core steps when registering a data source with JBoss EAP in Azure App Service: uploading the JDBC driver, adding the JDBC driver as a module, and registering the module.

                            App Service is a stateless hosting service, so the configuration commands for adding and registering the data source module must be scripted and applied as the container starts.

                            For more information, see Datasource Management in the JBoss EAP documentation.
                        </message>
                        <link title="Migrate JBoss EAP applications to JBoss EAP on Azure App Service - Datasources"
                              href="https://docs.microsoft.com/azure/developer/java/migration/migrate-jboss-eap-to-jboss-eap-on-azure-app-service#datasources"/>
                        <link title="Migrate JBoss EAP applications to JBoss EAP on Azure App Service - Set up data sources"
                              href="https://docs.microsoft.com/azure/developer/java/migration/migrate-jboss-eap-to-jboss-eap-on-azure-app-service#set-up-data-sources"/>
                        <link title="Datasource Management"
                              href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.4/html/configuration_guide/datasource_management"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <Context>

        <WatchedResource>WEB-INF/web.xml</WatchedResource>
        <WatchedResource>WEB-INF/tomcat-web.xml</WatchedResource>
        <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>

        <Resource name="jdbc/postgres"
                  auth="Container"
                  type="javax.sql.DataSource"
                  driverClassName="org.postgresql.Driver"
                  url="jdbc:postgresql://127.0.0.1:5432"
                  username="postgres"
                  password="yes"
                  maxActive="20"
                  maxIdle="10"
                  maxWait="-1"/>
    </Context>
    <Context>

        <WatchedResource>WEB-INF/web.xml</WatchedResource>
        <WatchedResource>WEB-INF/tomcat-web.xml</WatchedResource>
        <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>

        <Resource name="jdbc/postgres1"
                  auth="Container"
                  type="javax.sql.DataSource"
                  driverClassName="org.postgresql.Driver"
                  url="jdbc:postgresql://127.0.0.1:5432"
                  username="postgres"
                  password="yes"
                  maxActive="20"
                  maxIdle="10"
                  maxWait="-1"/>

        <Resource name="jdbc/postgres2"
                  auth="Container"
                  type="javax.sql.DataSource"
                  driverClassName="org.postgresql.Driver"
                  url="jdbc:postgresql://127.0.0.1:5432"
                  username="postgres"
                  password="yes"
                  maxActive="20"
                  maxIdle="10"
                  maxWait="-1"/>

        <NoResource name="jdbc/postgres"
                    auth="Container"
                    type="javax.sql.DataSource"
                    driverClassName="org.postgresql.Driver"
                    url="jdbc:postgresql://127.0.0.1:5432"
                    username="postgres"
                    password="yes"
                    maxActive="20"
                    maxIdle="10"
                    maxWait="-1"/>
    </Context>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="tomcat-to-azure-external-resources"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify external resources in a Tomcat configuration file.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>tomcat</tag>
        </metadata>
        <rules>
            <rule id="tomcat-to-azure-external-resources-01000">
                <when>
                    <xmlfile matches="/Context/Resource" in="context.xml"/>
                </when>
                <perform>
                    <hint title="External resources found in configuration file"
                          category-id="optional"
                          effort="5">
                        <message>
                            External resources are injected via Java Naming and Directory Interface (JNDI).
                            These resources can be:

                            * **Data Sources**: If your application relies on a database, consider using an Azure managed database (e.g. Azure PostgreSQL, Azure MySQL, Azure CosmosDB, etc.). Provision a database instance in Azure and configure the necessary connection string.

                            * **JMS Destinations**: If your application utilizes JMS resources, such as message queues or topics, consider using Azure Service Bus as a messaging service. Create the necessary queues or topics in Azure Service Bus and use the appropriate connection details provided by Azure Service Bus.

                            * **Mail Sessions**: If your application sends emails, consider using Azure Communication Services. It provides a variety of communication capabilities, including sending emails from your application.

                            * **Environment Variables**: If your application is configured through environment variables, consider user Azure App Configuration. It enables you to centrally manage and store application settings and configuration data. When dealing with secrets or passwords in your Tomcat application, it is recommended to use Azure Key Vault to securely store and manage sensitive information.

                            Review the Azure service offerings and choose the appropriate services for your specific needs.
                        </message>
                        <link title="Inventory external resources"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-tomcat-to-azure-spring-apps"/>
                        <link title="Azure services" href="https://azure.microsoft.com/products"/>
                        <tag>tomcat</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-static-content"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Read-only static content.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>static-content</tag>
        </metadata>
        <rules>
            <rule id="azure-static-content-01000">
                <!-- TODO
            We could improve this rule to make it less noisy:
            - we could skip the files that are called `index.html and index.html
            - we could look for HTML pages only located under src/main/resources 
            - we could look for HTML pages only located under src/main/webapp 
            -->
                <when>
                    <file filename="{*}.{extensions}"/>
                </when>
                <perform>
                    <hint title="Static content found in the application"
                          category-id="optional"
                          effort="5">
                        <message>
                            Your application currently serves static content directly. You may wish to consider moving static content to Azure Blob Storage and adding Azure CDN for lightning-fast downloads globally, and to also enable quicker changes to static content without the need of redeploying the entire application.

                            * **Azure Storage to store your static content**: Create an Azure Storage account to store your static content such as HTML, CSS, JavaScript, images, and other assets.

                            * **Provision an Azure CDN**: Configure the Azure Content Delivery Network endpoint to use your Blob Storage container as the origin. Enable the CDN caching and content delivery optimizations to improve performance and reduce latency.

                            * **Security**: Ensure that the appropriate access controls are applied to the Blob Storage container to secure your static content.

                            * **Global Distribution**: Azure CDN has a network of edge servers located globally. This ensures that your static content is cached and delivered from the nearest edge server to the end users, reducing latency and improving download speeds.

                            * **Performace**: Azure CDN handles dynamic content compression and optimization, further enhancing the delivery performance.

                            * **HTTPS Support**: Enable HTTPS support for your Azure CDN endpoint to ensure secure content delivery. Obtain an TLS certificate for your custom domain if needed, or use the Azure CDN default domain.
                        </message>
                        <link title="Azure Front Door and CDN documentation"
                              href="https://learn.microsoft.com/azure/frontdoor"/>
                        <link title="Configuring TLS for an application in Azure"
                              href="https://learn.microsoft.com/azure/cloud-services/cloud-services-configure-ssl-certificate-portal"/>
                        <link title="Static content found in the application"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#read-only-static-content"/>
                        <link title="Static website hosting in Azure Storage"
                              href="https://docs.microsoft.com/azure/storage/blobs/storage-blob-static-website"/>
                        <link title="Quickstart: Integrate an Azure Storage account with Azure CDN"
                              href="https://docs.microsoft.com/azure/cdn/cdn-create-a-storage-account-with-cdn"/>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(htm|html)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-database-config"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                For any database, identify the connection string.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>database</tag>
        </metadata>
        <rules>
            <rule id="azure-database-config-jdbc-01000">
                <when>
                    <or>
                        <filecontent filename="{*}.{extensions}" pattern="jdbc:"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.url"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.u-r-l"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.jdbc-url"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.username"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.user"/>
                        <filecontent filename="{*}.{extensions}" pattern="datasource.password"/>
                        <filecontent filename="{*}.{extensions}" pattern="jdbc.url"/>
                        <filecontent filename="{*}.{extensions}" pattern="jdbc.username"/>
                        <filecontent filename="{*}.{extensions}" pattern="jdbc.password"/>
                    </or>
                </when>
                <perform>
                    <hint title="JDBC connection found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a JDBC connection string, username or password in the configuration file. To migrate a Java application that uses a JDBC connection string to Azure, you can follow these recommendations:

                            * **Use a database that is fully managed on Azure**: Use databases such as Azure SQL, Azure Database for MySQL, or Azure Database for PostgreSQL.

                            * **Connect to databases using Service Connector**: Create service connection using **Service Connector** to connect your application to Azure SQL, Azure Database for MySQL, or Azure Database for PostgreSQL. Service Connector provides a secure and easy way to connect your application to Azure services without having to manage secrets or credentials in your application code.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="JDBC connection string found in configuration file"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#databases"/>
                        <link title="Use Spring Data JDBC with Azure Database for MySQL"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-jdbc-with-azure-mysql"/>
                        <link title="Use Spring Data JDBC with Azure Database for PostgreSQL"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-jdbc-with-azure-postgresql"/>
                        <link title="Use Spring Data JDBC with Azure SQL Database"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-jdbc-with-azure-sql-server"/>
                        <link title="Bind an Azure Database for PostgreSQL with service connector"
                              href="https://learn.microsoft.com/azure/service-connector/tutorial-java-spring-mysql"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <tag>jdbc</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(xml|properties|yaml|yml)"/>
                </where>
            </rule>
            <rule id="azure-database-config-mongodb-02000">
                <when>
                    <or>
                        <filecontent filename="{*}.{extensions}" pattern="mongodb:"/>
                        <filecontent filename="{*}.{extensions}" pattern="mongodb.uri"/>
                        <filecontent filename="{*}.{extensions}" pattern="mongodb.username"/>
                        <filecontent filename="{*}.{extensions}" pattern="mongodb.password"/>
                    </or>
                </when>
                <perform>
                    <hint title="MongoDB connection found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a MongoDB connection string. To migrate a Java application that uses a MongoDB connection string to Azure, you can follow these recommendations:

                            * Use a managed **Azure Cosmos DB for MongoDB**: Create a managed Cosmos DB for MongoDB database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Connect to Azure Cosmos DB for MongoDB using Service Connector**: Create service connection using **Service Connector** to connect your application to Azure Cosmos DB for MongoDB. Service Connector provides a secure and easy way to connect your application to Azure services without having to manage secrets or credentials in your application code.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="MongoDB connection string found in configuration file"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#databases"/>
                        <link title="Integrate Azure Cosmos DB for MongoDB with Service Connector"
                              href="https://learn.microsoft.com/azure/service-connector/how-to-integrate-cosmos-db"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <link title="How to use Spring Data MongoDB API with Azure Cosmos DB"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-mongodb-with-cosmos-db"/>
                        <link title="Spring Cloud Azure Starter Data Cosmos DB"
                              href="https://search.maven.org/artifact/com.azure.spring/spring-cloud-azure-starter-data-cosmos"/>
                        <tag>mongodb</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(xml|properties|yaml|yml)"/>
                </where>
            </rule>
            <rule id="azure-database-config-r2dbc-03000">
                <when>
                    <or>
                        <filecontent filename="{*}.{extensions}" pattern="r2dbc:"/>
                        <filecontent filename="{*}.{extensions}" pattern="r2dbc.username"/>
                        <filecontent filename="{*}.{extensions}" pattern="r2dbc.password"/>
                        <filecontent filename="{*}.{extensions}" pattern="r2dbc.url"/>
                    </or>
                </when>
                <perform>
                    <hint title="R2DBC connection found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a R2DBC connection string, username or password in the configuration file. To migrate a Java application that uses a R2DBC connection string to Azure, you can follow these recommendations:

                            * **Use a database that is fully managed on Azure**: Use databases such as Azure SQL, Azure Database for MySQL, or Azure Database for PostgreSQL.

                            * **Connect to databases using Service Connector**: Create service connection using **Service Connector** to connect your application to Azure SQL, Azure Database for MySQL, or Azure Database for PostgreSQL. Service Connector provides a secure and easy way to connect your application to Azure services without having to manage secrets or credentials in your application code.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="R2DBC connection string found in configuration file"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#databases"/>
                        <link title="Service Connector"
                              href="https://learn.microsoft.com/azure/service-connector/overview"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <link title="Use Spring Data R2DBC with Azure Database for MySQL"
                              href="https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-r2dbc-with-azure-mysql"/>
                        <link title="Use Spring Data R2DBC with Azure Database for PostgreSQL"
                              href="https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-r2dbc-with-azure-postgresql"/>
                        <link title="Use Spring Data R2DBC with Azure SQL Database"
                              href="https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-data-r2dbc-with-azure-sql-server"/>
                        <tag>r2dbc</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(xml|properties|yaml|yml)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <Configure class="org.eclipse.jetty.webapp.WebAppContext">
        <New id="ds" class="org.eclipse.jetty.plus.jndi.Resource">
            <Arg>jdbc/mybd1</Arg>
            <Arg>
                <New class="com.mchange.v2.c3p0.ComboPooledDataSource">
                    <Set name="driverClass">com.microsoft.sqlserver.jdbc.SQLServerDriver</Set>
                    <Set name="jdbcUrl">jdbc:jtds:sqlserver://url:1433/mybd1</Set>
                    <Set name="user">xx</Set>
                    <Set name="password">yy</Set>
                </New>
            </Arg>
        </New>

        <New id="ds2" class="org.eclipse.jetty.plus.jndi.Resource">
            <Arg>jdbc/mybd2</Arg>
            <Arg>
                <New class="com.mchange.v2.c3p0.ComboPooledDataSource">
                    <Set name="driverClass">com.microsoft.sqlserver.jdbc.SQLServerDriver</Set>
                    <Set name="jdbcUrl">jdbc:jtds:sqlserver://url:1433/mybd2</Set>
                    <Set name="user">xx</Set>
                    <Set name="password">yy</Set>
                </New>
            </Arg>
        </New>
    </Configure>
    <Configure class="org.eclipse.jetty.webapp.WebAppContext">
        <New id="ds" class="org.eclipse.jetty.plus.jndi.Resource">
            <Arg>jdbc/mybd1</Arg>
            <Arg>
                <New class="com.mchange.v2.c3p0.ComboPooledDataSource">
                    <Set name="driverClass">com.microsoft.sqlserver.jdbc.SQLServerDriver</Set>
                    <Set name="jdbcUrl">jdbc:jtds:sqlserver://url:1433/mybd1</Set>
                    <Set name="user">xx</Set>
                    <Set name="password">yy</Set>
                </New>
            </Arg>
        </New>

        <New id="ds2" class="org.eclipse.jetty.plus.jndi.Resource">
            <Arg>jdbc/mybd2</Arg>
            <Arg>
                <New class="com.mchange.v2.c3p0.ComboPooledDataSource">
                    <Set name="driverClass">com.microsoft.sqlserver.jdbc.SQLServerDriver</Set>
                    <Set name="jdbcUrl">jdbc:jtds:sqlserver://url:1433/mybd2</Set>
                    <Set name="user">xx</Set>
                    <Set name="password">yy</Set>
                </New>
            </Arg>
        </New>
    </Configure>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="jetty-to-azure-external-resources"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify external resources in a Jetty configuration file.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>jetty</tag>
        </metadata>
        <rules>
            <rule id="jetty-to-azure-external-resources-01000">
                <when>
                    <xmlfile matches="/Configure/New" in="jetty-env.xml"/>
                </when>
                <perform>
                    <hint title="External resources found in configuration file"
                          category-id="optional"
                          effort="5">
                        <message>
                            External resources are injected via Java Naming and Directory Interface (JNDI).
                            These resources can be:

                            * **Data Sources**: If your application relies on a database, consider using an Azure managed database (e.g. Azure PostgreSQL, Azure MySQL, Azure CosmosDB, etc.). Provision a database instance in Azure and configure the necessary connection string.

                            * **JMS Destinations**: If your application utilizes JMS resources, such as message queues or topics, consider using Azure Service Bus as a messaging service. Create the necessary queues or topics in Azure Service Bus and use the appropriate connection details provided by Azure Service Bus.

                            * **Mail Sessions**: If your application sends emails, consider using Azure Communication Services. It provides a variety of communication capabilities, including sending emails from your application.

                            * **Environment Variables**: If your application is configured through environment variables, consider user Azure App Configuration. It enables you to centrally manage and store application settings and configuration data. When dealing with secrets or passwords in your jetty application, it is recommended to use Azure Key Vault to securely store and manage sensitive information.

                            Review the Azure service offerings and choose the appropriate services for your specific needs.
                        </message>
                        <link title="Azure services" href="https://azure.microsoft.com/products"/>
                        <tag>jetty</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-system-config"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Find usages of System.getenv, System.getProperty, System.setProperty, System.setProperties
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>config</tag>
        </metadata>
        <rules>
            <rule id="azure-system-config-01000">
                <when>
                    <or>
                        <javaclass references="java.lang.System.getenv({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.System.getProperty({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.System.setProperty({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.System.setProperties({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="Environment variables/system properties"
                          category-id="optional"
                          effort="1">
                        <message>
                            The application uses environment variables/system properties.
                            To migrate a Java application that uses environment variables/system properties to Azure, you can follow these recommendations:

                            * **Identify environment variables and system properties**: Review the usage of environment variables and system properties and externalize them.

                            * **Add environment variables in Azure**: You can inject any per-service configuration settings into each service as environment variables.

                            * **Define system properties in JVM options**: Any system properties that the code depends on will need to be defined in JVM options.

                            * Consider using**Azure App Configuration**: You can also replace the usage of environment variables with **Azure App Configuration**. By migrating to Azure App Configuration, you can centralize and manage your application's configuration settings, making it easier to maintain and update them. Azure App Configuration provides features like versioning, dynamic updates, and integration with Azure Key Vault for secure storage of sensitive configuration values.
                        </message>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                        <link title="Configure per-service secrets and externalized settings"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#configure-per-service-secrets-and-externalized-settings"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-aws-config"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Check AWS related configurations.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>AWS</tag>
        </metadata>
        <rules>
            <rule id="azure-aws-config-credential-01000">
                <when>
                    <or>
                        <filecontent pattern="aws_access_key_id"/>
                        <filecontent pattern="aws_secret_access_key"/>
                        <filecontent pattern="aws.credentials"/>
                    </or>
                </when>
                <perform>
                    <hint title="AWS credential configuration"
                          category-id="mandatory"
                          effort="3">
                        <message>
                            The application contains AWS credential configuration.

                            * Migrate credentials to **Azure Key Vault**: Create an Azure Key Vault to securely store your application's credentials and sensitive information. Migrate the AWS credentials to Azure Key Vault, which provides a centralized and highly secure storage solution.

                            * **Modify application code**: Update the Java application's code to retrieve the required credentials from Azure Key Vault instead of AWS. Use the appropriate Azure SDK or libraries to integrate with Azure Key Vault and fetch the credentials securely during runtime.

                            * Implement **Azure Active Directory (Azure AD) authentication**: If the AWS credentials are used for authentication purposes, consider migrating to Azure AD for user authentication and authorization. Implement Azure AD authentication in your Java application to ensure secure access to Azure resources.
                        </message>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                        <link title="Quickstart: Azure Key Vault Secret client library for Java"
                              href="https://learn.microsoft.com/azure/key-vault/secrets/quick-create-java"/>
                        <link title="Azure Active Directory documentation"
                              href="https://learn.microsoft.com/azure/active-directory"/>
                    </hint>
                </perform>
            </rule>
            <rule id="azure-aws-config-region-02000">
                <when>
                    <or>
                        <filecontent pattern="aws.region"/>
                        <filecontent pattern="AWS_REGION"/>
                        <filecontent pattern="AWSRegion"/>
                    </or>
                </when>
                <perform>
                    <hint title="AWS region configuration" category-id="mandatory" effort="3">
                        <message>
                            The application contains AWS region configuration.

                            * Identify **Azure regions**: Determine the Azure regions that align with your application's requirements for availability, latency, compliance, and data residency. Azure provides a wide range of regions globally.

                            * Update **configuration settings**: Modify the Java application's configuration to replace the AWS region configuration with the corresponding Azure region configuration. Update the code or configuration files to reflect the Azure region names or identifiers.
                        </message>
                        <link title="Azure geographies"
                              href="https://azure.microsoft.com/explore/global-infrastructure/geographies"/>
                    </hint>
                </perform>
            </rule>
            <rule id="azure-aws-config-s3-03000">
                <when>
                    <or>
                        <filecontent pattern="aws.s3"/>
                    </or>
                </when>
                <perform>
                    <hint title="AWS S3 configuration" category-id="mandatory" effort="3">
                        <message>
                            The application contains AWS S3 configuration. Consider using Azure Blob Storage instead.

                            * Provision **Azure Blob Storage**: Create an Azure Blob Storage account in the Azure portal. Choose the appropriate storage tier (Hot, Cool, or Archive) based on your application's data access patterns and cost considerations.

                            * **Update application code**: Modify the Java application's code to replace AWS SDK calls with the equivalent Azure Storage SDK calls for Azure Blob Storage. Update the code to authenticate and interact with Azure Blob Storage using the Azure SDK for Java.

                            * **Map S3 functionality** to Azure Blob Storage: Understand the differences between AWS S3 and Azure Blob Storage, and adjust your application logic accordingly. Map S3 concepts (buckets, objects, permissions, etc.) to their Azure Blob Storage equivalents (containers, blobs, shared access signatures, etc.).

                            * **Migrate data** from S3 to Azure Blob Storage: Plan and execute the migration of your data from AWS S3 to Azure Blob Storage. You can use Azure Storage Data Transfer Tool, AzCopy, or other migration tools to copy the data from S3 buckets to Azure Blob Storage containers.

                            * Update **access permissions**: Adjust the access permissions and policies in Azure Blob Storage to match your application's requirements. Azure provides various options for controlling access, including shared access signatures (SAS), Azure AD authentication, and role-based access control (RBAC).

                            * Validate functionality and **performance**: Thoroughly test the updated application to ensure that it can read from and write to Azure Blob Storage correctly. Validate the performance of data transfer and any other operations to ensure they meet your application's requirements.
                        </message>
                        <link title="Azure Blob Storage documentation"
                              href="https://learn.microsoft.com/azure/storage/blobs"/>
                        <link title="Quickstart: Azure Blob Storage client library for Java"
                              href="https://learn.microsoft.com/azure/storage/blobs/storage-quickstart-blobs-java"/>
                        <link title="Move your data from AWS S3 to Azure Storage using AzCopy"
                              href="https://azure.microsoft.com/blog/move-your-data-from-aws-s3-to-azure-storage-using-azcopy"/>
                    </hint>
                </perform>
            </rule>
            <rule id="azure-aws-config-sqs-04000">
                <when>
                    <or>
                        <filecontent pattern="aws.sqs"/>
                    </or>
                </when>
                <perform>
                    <hint title="Amazon Simple Queue Service configuration"
                          category-id="mandatory"
                          effort="3">
                        <message>
                            The application contains Amazon Simple Queue Service configuration. Consider using Azure Service Bus instead.

                            * **Provision Azure Service Bus**: Create an Azure Service Bus namespace in Azure. Azure Service Bus provides reliable message queuing and publish/subscribe capabilities, serving as an equivalent messaging service to Amazon SQS.

                            * **Update application code**: Modify the Java application's code to replace the AWS SDK calls with the equivalent Azure Service Bus client libraries and APIs. Update the code to authenticate and interact with Azure Service Bus using the Azure SDK for Java.

                            * **Map SQS functionality** to Azure Service Bus: Understand the differences between Amazon SQS and Azure Service Bus and adjust your application logic accordingly. Map SQS concepts (queues, messages, visibility timeouts, etc.) to their Azure Service Bus equivalents (queues, messages, lock duration, etc.).

                            * **Migrate queues and messages**: Plan and execute the migration of your queues and messages from Amazon SQS to Azure Service Bus.
                        </message>
                        <link title="Azure Service Bus documentation"
                              href="https://learn.microsoft.com/azure/service-bus-messaging"/>
                        <link title="Azure Service Bus libraries for Java"
                              href="https://learn.microsoft.com/java/api/overview/azure/service-bus"/>
                    </hint>
                </perform>
            </rule>
            <rule id="azure-aws-config-secret-manager-05000">
                <when>
                    <or>
                        <filecontent pattern="aws.secretsmanager"/>
                        <filecontent pattern="aws-secretsmanager"/>
                    </or>
                </when>
                <perform>
                    <hint title="AWS Secrets Manager configuration"
                          category-id="mandatory"
                          effort="3">
                        <message>
                            The application contains AWS Secrets Manager configuration. Consider using Azure Key Vault instead.

                            * **Provision Azure Key Vault**: Create an Azure Key Vault in Azure. Azure Key Vault provides a secure and centralized location for storing secrets, certificates, and keys.

                            * **Migrate secrets** to Azure Key Vault: Identify the secrets stored in AWS Secrets Manager and migrate them to Azure Key Vault. Use the Azure Key Vault SDK or CLI to programmatically create the equivalent secrets in Azure Key Vault or manually import them as needed.

                            * **Update application code**: Modify the Java application's code to replace the AWS SDK calls with the equivalent Azure Key Vault SDK or libraries. Update the code to authenticate and retrieve secrets from Azure Key Vault using the Azure SDK for Java.

                            * **Secure access** to Azure Key Vault: Implement access control and security measures for Azure Key Vault. Configure Azure AD authentication, RBAC, and access policies to ensure that only authorized applications and users can access the secrets stored in Azure Key Vault.
                        </message>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                        <link title="Quickstart: Azure Key Vault Secret client library for Java"
                              href="https://learn.microsoft.com/azure/key-vault/secrets/quick-create-java"/>
                        <link title="Azure Key Vault CLI"
                              href="https://learn.microsoft.com/cli/azure/keyvault"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <Configuration status="WARN">
        <Appenders>
            <File name="LOGFILE" fileName="logs/app.log">
                <PatternLayout>
                    <Pattern>%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n</Pattern>
                </PatternLayout>
            </File>
        </Appenders>
        <Loggers>
            <Root level="info">
                <AppenderRef ref="LOGFILE"/>
            </Root>
        </Loggers>
    </Configuration>
    <configuration>
        <appender name="FILE" class="ch.qos.logback.core.FileAppender">
            <file>${user.home}/database.log</file>
            <append>false</append>
            <encoder>
                <pattern>%-5relative %-5level %logger{35} - %msg%n</pattern>
            </encoder>
        </appender>

        <logger name="jdbc" level="OFF"/>
        <logger name="jdbc.sqlonly" level="debug"/>

        <root level="info">
            <appender-ref ref="FILE"/>
        </root>
    </configuration>
    <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
        <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
            <layout class="org.apache.log4j.PatternLayout">
                <param name="ConversionPattern"
                       value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
            </layout>
        </appender>
        <root>
            <level value="debug"/>
            <appender-ref ref="CONSOLE"/>
        </root>
    </log4j:configuration>
    <log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
        <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
            <layout class="org.apache.log4j.PatternLayout">
                <param name="ConversionPattern"
                       value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
            </layout>
        </appender>
        <appender name="FILE" class="org.apache.log4j.FileAppender">
            <layout class="org.apache.log4j.PatternLayout">
                <param name="ConversionPattern"
                       value="%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n"/>
            </layout>
            <param name="File" value="logfile.log"/>
        </appender>
        <root>
            <level value="debug"/>
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="FILE"/>
        </root>
    </log4j:configuration>
    <datasources>
        <xa-datasource>
            <jndi-name>example_ds</jndi-name>
            <track-connection-by-tx>false</track-connection-by-tx>
            <isSameRM-override-value>false</isSameRM-override-value>
            <min-pool-size>5</min-pool-size>
            <max-pool-size>100</max-pool-size>
            <blocking-timeout-millis>5000</blocking-timeout-millis>
            <idle-timeout-minutes>15</idle-timeout-minutes>
            <transaction-isolation>TRANSACTION_READ_COMMITTED</transaction-isolation>
            <xa-datasource-class>oracle.jdbc.xa.client.OracleXADataSource</xa-datasource-class>
            <xa-datasource-property name="URL">jdbc:oracle:thin:@otto.na.ad.atg.com:1521:ora10r2</xa-datasource-property>
            <xa-datasource-property name="User">username</xa-datasource-property>
            <xa-datasource-property name="Password">password</xa-datasource-property>
            <exception-sorter-class-name>
                org.jboss.resource.adapter.jdbc.vendor.OracleExceptionSorter
            </exception-sorter-class-name>
        </xa-datasource>
    </datasources>
    <datasources>
        <datasource jndi-name="java:jboss/datasources/DeployedDS"
                    enabled="true"
                    use-java-context="true"
                    pool-name="H2DS">
            <connection-url>jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</connection-url>
            <driver>h2</driver>
            <pool/>
            <security>
                <user-name>sa</user-name>
                <password>sa</password>
            </security>
        </datasource>
        <xa-datasource jndi-name="java:/H2XADS" pool-name="H2XADS">
            <xa-datasource-class>org.h2.jdbcx.JdbcDataSource</xa-datasource-class>
            <xa-datasource-property name="URL">jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</xa-datasource-property>
            <driver>h2</driver>
            <security>
                <user-name>sa</user-name>
                <password>sa</password>
            </security>
        </xa-datasource>
    </datasources>
    <datasources>
        <datasource jndi-name="java:jboss/datasources/MyApplication"
                    pool-name="MyApplication"
                    enabled="true"
                    use-java-context="true">
            <connection-url>jdbc:postgresql://localhost:5432/myapplication</connection-url>
            <driver>postgresql-9.4.1208.jar</driver>
            <security>
                <user-name>postgres</user-name>
                <password>1234</password>
            </security>
        </datasource>
    </datasources>
    <Context>
        <Resource name="jdbc/TestDB"
                  auth="Container"
                  type="javax.sql.DataSource"
                  driverClassName="com.mysql.jdbc.Driver"
                  url="jdbc:mysql://localhost:3306/testdb"
                  username="dbuser"
                  password="dbpassword"
                  maxTotal="20"
                  maxIdle="10"
                  maxWaitMillis="-1"/>
    </Context>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>3.0.6</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
        <groupId>com.example</groupId>
        <artifactId>demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <name>demo</name>
        <description>Demo project for Spring Boot</description>
        <properties>
            <java.version>17</java.version>
        </properties>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
        </dependencies>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                </plugin>
            </plugins>
        </build>

    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>3.0.6</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
        <groupId>com.example</groupId>
        <artifactId>demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <name>demo</name>
        <description>Demo project for Spring Boot</description>
        <properties>
            <java.version>19</java.version>
        </properties>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
        </dependencies>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                </plugin>
            </plugins>
        </build>

    </project>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>2.5.12</version>
            <relativePath/>
            <!-- lookup parent from repository -->
        </parent>
        <groupId>com.example</groupId>
        <artifactId>demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <name>demo</name>
        <description>Demo project for Spring Boot</description>
        <properties>
            <java.version>1.7</java.version>
        </properties>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
        </dependencies>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                </plugin>
            </plugins>
        </build>

    </project>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-password"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Check all properties and configuration files and all environment variables on the production deployment(s) for any secret strings and passwords.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <sourceTechnology id="eap" versionRange="[7,8)"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>password</tag>
            <tag>security</tag>
        </metadata>
        <rules>
            <rule id="azure-password-01000">
                <when>
                    <or>
                        <filecontent filename="application{*}.{extensions}" pattern="{password}"/>
                        <xmlfile matches="//password"/>
                        <!-- any 'Password' element -->
                        <xmlfile matches="//*[@name='Password']"/>
                        <!-- Any element with a 'Password' property -->
                    </or>
                </when>
                <perform>
                    <hint title="Password found in configuration file"
                          category-id="potential"
                          effort="3">
                        <message>
                            Using clear passwords in property files is a security risk, as they can be easily compromised if the files are accessed by unauthorized individuals. To enhance the security of your application, it is recommended to employ secure credential management practices.

                            * **Azure Key Vault**: Utilize Azure Key Vault to securely store and manage your application's passwords and other sensitive credentials. Azure Key Vault provides a centralized and highly secure location for storing secrets, keys, and certificates.

                            * **Passwordless connections**: You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <link title="Password found in configuration file"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#inventory-configuration-sources-and-secrets"/>
                        <link title="Read a secret from Azure Key Vault in a Spring Boot application"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-key-vault"/>
                        <link title="Azure Spring Boot Starter for Azure Key Vault Secrets"
                              href="https://search.maven.org/artifact/com.azure.spring/azure-spring-boot-starter-keyvault-secrets"/>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="password">
                    <matches pattern="(password|pwd)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-file-system"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Any usage of the file system on the application server will require reconfiguration or, in rare cases, architectural changes.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,2.4.0.Final"/>
            </dependencies>
            <sourceTechnology id="eap" versionRange="[7,8)"/>
            <sourceTechnology id="springboot"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>file-system</tag>
        </metadata>
        <rules>
            <rule id="azure-file-system-02000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{path}"/>
                </when>
                <perform>
                    <hint title="Relative path found" category-id="optional" effort="5">
                        <message>
                            Relative path found in the application. An application running inside a container could lose access to a file in local storage.
                            To migrate a Java application that uses file system to Azure:

                            * **Identify the usage of the file system**: Find any instances where your services write to and/or read from the local file system. Identify where short-term/temporary files are written and read and where long-lived files are written and read.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Relative path found in the application"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#determine-whether-and-how-the-file-system-is-used"/>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(java|properties|yaml|yml)"/>
                </where>
                <where param="path">
                    <matches pattern="\.\/."/>
                </where>
            </rule>
            <rule id="azure-file-system-03000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{path}"/>
                </when>
                <perform>
                    <hint title="Home path found" category-id="optional" effort="5">
                        <message>
                            Home path found in the application. An application running inside a container could lose access to a file in local storage.
                            To migrate a Java application that uses file system to Azure:

                            * **Identify the usage of the file system**: Find any instances where your services write to and/or read from the local file system. Identify where short-term/temporary files are written and read and where long-lived files are written and read.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Home path found in the application"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#determine-whether-and-how-the-file-system-is-used"/>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(java|properties|yaml|yml)"/>
                </where>
                <where param="path">
                    <matches pattern="\/home"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-tas-binding"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Check configurations for VMware Tanzu Application Service (TAS) service bindings
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <sourceTechnology id="springboot"/>
            <sourceTechnology id="eap" versionRange="[7,8)"/>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
        </metadata>
        <rules>
            <rule id="azure-tas-binding-01000">
                <when>
                    <filecontent filename="{*}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Tanzu Application Service service bindings"
                          category-id="potential"
                          effort="3">
                        <message>
                            The application has configuration for VMware Tanzu Application Service (TAS) service bindings.
                            To migrate a Java application that uses TAS service bindings to Azure, you can follow these recommendations:

                            * Examine the VCAP_SERVICES variable for configuration settings of external services bound to the application

                            * Consider using Service Connector to connect Azure compute services to other backing services.
                            This service configures the network settings and connection information (for example, generating environment variables) between compute services and target backing services in management plane.
                        </message>
                        <link title="Java to Azure migration: resources configured through TAS"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-enterprise-tier#resources-configured-through-vmware-tanzu-application-service-tas-formerly-pivotal-cloud-foundry"/>
                        <link title="TAS (Cloud Foundry) environment variable: VCAP_SERVICES"
                              href="https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html#VCAP-SERVICES"/>
                        <link title="What is Service Connector"
                              href="https://learn.microsoft.com/azure/service-connector/overview"/>
                        <link title="Create a service connection in Azure Spring Apps from the Azure portal"
                              href="https://learn.microsoft.com/azure/service-connector/quickstart-portal-spring-cloud-connection?toc=%2Fazure%2Fspring-apps%2Ftoc.json&amp;bc=%2Fazure%2Fspring-apps%2Fbreadcrumb%2Ftoc.json"/>
                    </hint>
                </perform>
                <where param="pattern">
                    <matches pattern="\W(VCAP_SERVICES)\W"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-cache"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify any external caches in use.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>cache</tag>
            <tag>redis</tag>
        </metadata>
        <rules>
            <rule id="azure-cache-redis-01000">
                <when>
                    <or>
                        <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                    </or>
                </when>
                <perform>
                    <hint title="Redis Cache connection string found"
                          category-id="information"
                          effort="0">
                        <message>
                            Redis Cache connection string, username, or password used in this application. To migrate a Java application that uses a Redis Cache connection string to Azure, you can follow these recommendations:

                            * **Provision an Azure Cache for Redis**: Checkout Azure Cache for Redis for a fully managed cache on Azure. You can take advantage of a managed Redis service that offers scalability, high availability, and monitoring capabilities. **Azure Cache for Redis** provides features like data persistence, automatic failover, and built-in support for Redis commands, allowing you to leverage the benefits of Redis caching in your application running on Azure. Configure the cache size and other relevant settings based on your application's requirements.

                            * **Update your Java code**: Replace the embedded Redis cache code in your Java application with the Azure Cache for Redis client libraries or SDKs. Update the code that establishes a connection to the Redis cache and performs cache-related operations.

                            * **Connect to Azure Cache for Redis**: Connect your app to Azure Cache for Redis on azure by **Service Connector**. Instead of manually configuring connection string in your applications, you can automatically connect Azure Cache for Redis to your applications.
                        </message>
                        <link title="Connect Azure Cache for Redis to your application in Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-bind-redis?tabs=Java%2CService-Connector"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Caching guidance"
                              href="https://learn.microsoft.com/azure/architecture/best-practices/caching"/>
                        <link title="Redis Cache found in the application"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#identify-external-caches"/>
                        <tag>redis</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="(redis|jedis|lettuce)\.(.*\.)?(url|host|nodes|username|password)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-java-version"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Check non-LTS Java versions
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>version</tag>
        </metadata>
        <rules>
            <rule id="azure-java-version-01000">
                <when>
                    <xmlfile matches="//m:java.version[windup:matches(text(), '{v}')]"
                             in="pom.xml"
                             as="result">
                        <namespace prefix="m" uri="http://maven.apache.org/POM/4.0.0"/>
                    </xmlfile>
                </when>
                <perform>
                    <iteration over="result">
                        <hint title="Non-LTS version Java" category-id="mandatory" effort="3">
                            <message>
                                The application is using non-LTS version Java. JDK on LTS version is recommended, i.e. **Java 8**, **Java 11** or **Java 17**.

                                * Choose a **supported Java version**: Determine the most suitable supported Java version provided by Azure. As of now, Azure supports Java 8, Java 11, and Java 17.

                                * **Update Java Development Kit** (JDK): Update the JDK in your development environment and build pipelines to the chosen supported version. This ensures that your application is built and packaged using the compatible Java version.

                                * Address **code compatibility**: Review your application's codebase for any potential compatibility issues with the target Java version. Update deprecated APIs or features, address any language or library changes, and ensure that your code follows best practices and standards.

                                * **Test thoroughly**: Execute a comprehensive testing process to verify the compatibility and functionality of your application with the new Java version. Perform unit tests, integration tests, and system tests to validate that all components and dependencies work as expected.

                                * **Monitor performance**: Once migrated to the supported Java version, closely monitor the performance of your application in the Azure environment. Utilize Azure Monitoring tools and logging mechanisms to identify any performance bottlenecks or issues that may arise due to the Java version change.
                            </message>
                            <link title="Supported Java versions and update schedule"
                                  href="https://learn.microsoft.com/azure/developer/java/fundamentals/java-support-on-azure#supported-java-versions-and-update-schedule"/>
                            <link title="Microsoft Build of OpenJDK"
                                  href="https://learn.microsoft.com/java/openjdk"/>
                            <link title="Java on Azure developer tools documentation"
                                  href="https://learn.microsoft.com/azure/developer/java/fundamentals"/>
                            <link title="Azure Monitor documentation"
                                  href="https://learn.microsoft.com/azure/azure-monitor"/>
                        </hint>
                    </iteration>
                </perform>
                <where param="v">
                    <matches pattern="(9|10|12|13|14|15|16|19|20).*"/>
                </where>
            </rule>
            <rule id="azure-java-version-02000">
                <when>
                    <xmlfile matches="//m:java.version[windup:matches(text(), '{v}')]"
                             in="pom.xml"
                             as="result">
                        <namespace prefix="m" uri="http://maven.apache.org/POM/4.0.0"/>
                    </xmlfile>
                </when>
                <perform>
                    <iteration over="result">
                        <hint title="Java version found to be lower than JAVA_8"
                              category-id="mandatory"
                              effort="3">
                            <message>
                                The application is using a Java version lower than Java 8. JDK on LTS version is recommended, i.e. **Java 8**, **Java 11** or **Java 17**.
                                It is strongly recommended to plan and execute a migration strategy to upgrade your application to a newer supported Java version.

                                * **Unsupported Java versions**: Azure supports Java 8, Java 11, and Java 17. Versions of Java older than Java 8 are not supported, which means you may encounter compatibility issues and security vulnerabilities.

                                * **Security risks**: Older Java versions may have known security vulnerabilities that can expose your application and infrastructure to potential attacks. Migrating to a supported version ensures that you benefit from the latest security patches and updates.

                                * **Long-term support**: Supported Java versions receive long-term support (LTS) from the Java community, including bug fixes and updates. Migrating to a supported version provides you with a stable and well-maintained platform for your application.
                            </message>
                            <link title="Transition from Java 8 to Java 11"
                                  href="https://learn.microsoft.com/java/openjdk/transition-from-java-8-to-java-11"/>
                            <link title="Supported Java versions and update schedule"
                                  href="https://learn.microsoft.com/azure/developer/java/fundamentals/java-support-on-azure#supported-java-versions-and-update-schedule"/>
                            <link title="Microsoft Build of OpenJDK"
                                  href="https://learn.microsoft.com/java/openjdk"/>
                            <link title="Java on Azure developer tools documentation"
                                  href="https://learn.microsoft.com/azure/developer/java/fundamentals"/>
                        </hint>
                    </iteration>
                </perform>
                <where param="v">
                    <matches pattern="1\.[0-7]"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-mq-config"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset identifies message queue connection strings, usernames, or passwords.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>message queue</tag>
        </metadata>
        <rules>
            <rule id="azure-mq-config-kafka-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Kafka connection string, username or password found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a Kafka connection string or password. To migrate a Java application that uses a Kafka connection string to Azure, you can follow these recommendations:

                            * **Provision an Apache Kafka for Confluent Cloud**: Consider moving to Apache Kafka for Confluent Cloud to reduce the burden of cross-platform management. Microsoft partnered with Confluent Cloud to build an integrated provisioning layer from Azure to Confluent Cloud. You can easily integrate and manage Confluent Cloud with your Azure applications.

                            * **Connect to Apache Kafka for Confluent Cloud using Service Connector**: Create service connection using **Service Connector** to connect your Apache Kafka on Confluent Cloud to your azure app. Instead of manually configuring connection string in your applications, you can automatically connect Apache Kafka for Confluent Cloud using Service Connector.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="Spring Boot app to Kafka on Confluent Cloud"
                              href="https://learn.microsoft.com/azure/service-connector/tutorial-java-spring-confluent-kafka"/>
                        <link title="Apache Kafka on Confluent Cloud - Azure Native ISV Service Documentation"
                              href="https://learn.microsoft.com/azure/partner-solutions/apache-kafka-confluent-cloud"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <tag>kafka</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Kafka Client</technology-tag>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="kafka\.(.*\.)?(properties\.)?(bootstrap[\.-]servers|sasl\.jaas\.config|schema\.registry)"/>
                </where>
            </rule>
            <!-- Rule for detecting RabbitMQ configurations -->
            <rule id="azure-mq-config-rabbitmq-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="RabbitMQ connection string, username or password found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses a RabbitMQ connection string, username, or password. To migrate a Java application that uses a RabbitMQ connection string to Azure, you can follow these recommendations:

                            * Provision **Azure Service Bus**: Replace RabbitMQ with Azure Service Bus, a fully managed messaging service that offers reliable message queuing and publish/subscribe capabilities.

                            * **Connect to Azure Service Bus using Service Connector**: Create service connection using **Service Connector** to connect your Azure Service Bus to your azure app. Instead of manually configuring connection string in your applications, you can automatically connect Azure Service Bus using Service Connector.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.
                        </message>
                        <link title="Azure Service Bus documentation"
                              href="https://learn.microsoft.com/azure/service-bus-messaging"/>
                        <link title="Service connection in Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/service-connector/quickstart-portal-spring-cloud-connection"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <tag>RabbitMQ Client</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">RabbitMQ Client</technology-tag>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="rabbitmq\.(.*\.)?(addresses|host|virtual-host|username|password)"/>
                </where>
            </rule>

            <!-- Rule for detecting Artemis configurations -->
            <rule id="azure-mq-config-artemis-01000">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="ActiveMQ Artemis connection string, username or password found in configuration file"
                          category-id="information"
                          effort="0">
                        <message>
                            The application uses an ActiveMQ Artemis connection string, username, or password. To migrate a Java application that uses an ActiveMQ Artemis connection string to Azure, you can follow these recommendations:

                            * Provision **Azure Service Bus**: Replace ActiveMQ with Azure Service Bus, a fully managed messaging service that offers reliable message queuing and publish/subscribe capabilities.

                            * **Connect to Azure Service Bus using Service Connector**: Create service connection using **Service Connector** to connect your Azure Service Bus to your azure app. Instead of manually configuring connection string in your applications, you can automatically connect Azure Service Bus using Service Connector.

                            * **Passwordless connections for Azure services**: Consider using passwordless connections for Azure services. You can provide an additional layer of security and convenience for accessing resources in Azure by eliminating the need for passwords. This way you can reduce the risk of password-related vulnerabilities, such as weak passwords or password theft.

                        </message>
                        <link title="Azure Service Bus documentation"
                              href="https://learn.microsoft.com/azure/service-bus-messaging"/>
                        <link title="Migrate existing Java Message Service applications from Apache ActiveMQ to Azure Service Bus"
                              href="https://learn.microsoft.com/azure/service-bus-messaging/migrate-jms-activemq-to-servicebus"/>
                        <link title="Service connection in Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/service-connector/quickstart-portal-spring-cloud-connection"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <tag>ActiveMQ</tag>
                    </hint>
                    <technology-tag level="INFORMATIONAL">ActiveMQ</technology-tag>
                </perform>
                <where param="extensions">
                    <matches pattern="(properties|yaml|yml)"/>
                </where>
                <where param="pattern">
                    <matches pattern="artemis\.(broker-url|user|password)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="azure-keystore-certificates"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Detect JKS files and certificates
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>JKS</tag>
        </metadata>
        <rules>
            <rule id="azure-keystore-certificates-01000">
                <when>
                    <file filename="{*}.jks"/>
                </when>
                <perform>
                    <hint title="Java KeyStore file found" effort="3" category-id="potential">
                        <message>
                            The application has a Java KeyStore file. You can migrate it to Azure Key Vault.

                            * **Migrate the Java KeyStore to Azure Key Vault**: With Azure Key Vault you can centralize and securely manage your cryptographic keys and certificates in a highly available and scalable service. Azure Key Vault provides robust access control and auditing capabilities, ensuring that your keys and certificates are protected and accessible only to authorized entities.

                            * **Update your Java application**: Modify your Java application's code to retrieve the keys and certificates from Azure Key Vault. Update the code that references the Java KeyStore to use Azure Key Vault APIs for accessing the cryptographic materials.

                            * **Secure access to Azure Key Vault**: Configure appropriate access policies and permissions for your Azure Key Vault to ensure that only authorized users and applications can access the keys and certificates stored in it.
                        </message>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                    </hint>
                </perform>
            </rule>
            <rule id="azure-keystore-certificates-02000">
                <when>
                    <or>
                        <javaclass references="java.security.KeyStore.getInstance({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.security.KeyStore.load({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="The application loads certificates into a KeyStore"
                          effort="3"
                          category-id="potential">
                        <message>
                            The application loads a KeyStore from a file or an input stream. To migrate this code to Azure, you would need to modify it so it retrieves the cryptographic material from Azure Key Vault instead.

                            * **Create an Azure Key Vault**: Azure Key Vault is a secure storage service that allows you to store and manage cryptographic keys, secrets, and certificates.

                            * **Import keys and certificates into Azure Key Vault**: Use the Azure Key Vault Java SDK or Azure CLI to import the keys and certificates into Azure Key Vault. Create corresponding key and certificate objects in Azure Key Vault and import the key material and certificates obtained from the existing KeyStore.

                            * **Update your Java code**: Modify your Java code that to retrieve the cryptographic material from Azure Key Vault. Instead of loading from a file or input stream, use the Azure Key Vault Java SDK to access the keys and certificates stored in Azure Key Vault. Update the code to authenticate and retrieve the cryptographic material using Azure.
                        </message>
                        <link title="Azure Key Vault documentation"
                              href="https://learn.microsoft.com/azure/key-vault"/>
                        <link title="Azure Key Vault JCA client library for Java"
                              href="https://learn.microsoft.com/java/api/overview/azure/security-keyvault-jca-readme"/>
                        <link title="Azure Key Vault Certificate client library for Java"
                              href="https://learn.microsoft.com/java/api/overview/azure/security-keyvault-certificates-readme"/>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="apm"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify Application Performance Management dependencies.
                This ruleset overrides the rules/rules-reviewed/technology-usage/apm.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>apm</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="apm-00000">
                <when>
                    <or>
                        <project>
                            <artifact groupId="com.microsoft.azure" artifactId="{*}applicationinsights{*}"/>
                        </project>
                        <file filename="applicationinsights{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Application Performance Management (APM) tool - Application Insights"
                          category-id="mandatory"
                          effort="1">
                        <message>
                            To migrate a Java application that uses Application Insights to Azure, you can follow this recommendation:

                            * **Configure Application Insights**: To connect Application Insights with Java applications deployed on Azure, you can turn on Application Insights in the portal page of your app or configure it through Azure CLI. For a detailed guide, please refer to the following documentation links.
                        </message>
                        <link title="Configure Application Insights to connect with Azure App Service"
                              href="https://learn.microsoft.com/azure/app-service/configure-language-java#configure-application-insights"/>
                        <link title="Configure Application Insights to connect with Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-application-insights#manage-application-insights-using-the-azure-portal"/>
                        <link title="Application Insights"
                              href="https://learn.microsoft.com/azure/azure-monitor/app/app-insights-overview"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Application Insights</technology-tag>
                </perform>
            </rule>
            <rule id="apm-00001">
                <when>
                    <or>
                        <project>
                            <artifact groupId="{*}newrelic{*}" artifactId="{*}"/>
                        </project>
                        <file filename="newrelic{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Application Performance Management (APM) tool - New Relic"
                          category-id="mandatory"
                          effort="1">
                        <message>
                            To migrate a Java application that uses New Relic to Azure, you can follow this recommendation:

                            * **Configure New Relic**: Connect New Relic with Java applications deployed on Azure by Azure portal or Azure CLI. For a detailed guide, please refer to the following documentation links.
                        </message>
                        <link title="Configure New Relic for Azure App Service"
                              href="https://learn.microsoft.com/azure/app-service/configure-language-java#configure-new-relic"/>
                        <link title="Configure New Relic for Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-new-relic-monitor"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">New Relic</technology-tag>
                </perform>
            </rule>
            <rule id="apm-00002">
                <when>
                    <or>
                        <project>
                            <artifact groupId="{*}elastic.apm{*}" artifactId="{*}"/>
                        </project>
                        <file filename="elastic-apm{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Application Performance Management (APM) tool - Elastic APM"
                          category-id="mandatory"
                          effort="3">
                        <message>
                            To migrate a Java application that uses Elastic APM to Azure, you can follow this recommendation:

                            * **Deploy Elastic on Azure**: It is recommended to deploy and manage Elastic on Azure. You can get started with Elastic Cloud on Azure Marketplace.

                            * **Integrate Elastic APM**: To connect Elastic APM with your Java applications deployed on Azure, you can configure the integration based on the specific Azure service you want to use.
                        </message>
                        <link title="Configure Elastic APM for Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-elastic-apm-java-agent-monitor"/>
                        <link title="Deploy and manage Elastic on Azure"
                              href="https://www.elastic.co/blog/getting-started-with-the-azure-integration-enhancement"/>
                        <link title="Integrate Elastic APM on Azure"
                              href="https://docs.elastic.co/integrations/azure"/>
                        <link title="Microsoft Azure monitoring with Elastic Observability"
                              href="https://www.elastic.co/observability/azure-monitoring"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Elastic APM</technology-tag>
                </perform>
            </rule>
            <rule id="apm-00003">
                <when>
                    <or>
                        <file filename="dynatrace{*}.jar"/>
                        <file filename="liboneagent.so"/>
                        <file filename="dtjavaagent.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Application Performance Management (APM) tool - Dynatrace"
                          category-id="mandatory"
                          effort="3">
                        <message>
                            To migrate a Java application that uses Dynatrace to Azure, you can follow this recommendation:

                            * **Integrate Dynatrace**: To connect Dynatrace with your Java applications deployed on Azure, you can configure the integration based on the specific Azure service you want to use.
                        </message>
                        <link title="Monitor Azure App Service using Dynatrace OneAgent"
                              href="https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-cloud-platforms/microsoft-azure-services/azure-integrations/azure-appservice"/>
                        <link title="Monitor Azure Spring Apps using Dynatrace OneAgent"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-dynatrace-one-agent-monitor"/>
                        <link title="Integrate Dynatrace on Azure"
                              href="https://www.dynatrace.com/support/help/setup-and-configuration/setup-on-cloud-platforms/microsoft-azure-services/azure-integrations"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Dynatrace</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="security"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset provides analysis of Java security libraries.
                This ruleset overrides the rules/rules-reviewed/technology-usage/security.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="security-01900">
                <when>
                    <file filename="{*}saml{*}.jar"/>
                </when>
                <perform>
                    <hint title="Embedded library - SAML"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds a SAML library. The Microsoft identity platform uses SAML and other protocols to enable applications to provide a Single Sign-On experience.

                            By migrating your SSO implementation to Azure AD with SAML, you leverage the capabilities of Azure AD for managing identities and enabling secure SSO across your applications. Azure AD offers features like multi-factor authentication, conditional access policies, and seamless integration with various SaaS applications, providing a robust and scalable solution for identity and access management in the cloud.
                        </message>
                        <link title="SAML authentication with Azure Active Directory"
                              href="https://learn.microsoft.com/azure/active-directory/fundamentals/auth-saml"/>
                        <link title="How the Microsoft identity platform uses the SAML protocol"
                              href="https://learn.microsoft.com/azure/active-directory/develop/saml-protocol-reference"/>
                        <link title="Microsoft identity platform documentation"
                              href="https://learn.microsoft.com/azure/active-directory/develop"/>
                        <link title="Azure Active Directory documentation"
                              href="https://learn.microsoft.com/azure/active-directory"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">SAML</technology-tag>
                </perform>
            </rule>
            <rule id="security-02800">
                <when>
                    <file filename="{*}opensaml{*}.jar"/>
                </when>
                <perform>
                    <hint title="Embedded library - OpenSAML"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds an OpenSAML library. The Microsoft identity platform uses SAML and other protocols to enable applications to provide a Single Sign-On experience.

                            By migrating your SSO implementation to Azure AD with SAML, you leverage the capabilities of Azure AD for managing identities and enabling secure SSO across your applications. Azure AD offers features like multi-factor authentication, conditional access policies, and seamless integration with various SaaS applications, providing a robust and scalable solution for identity and access management in the cloud.
                        </message>
                        <link title="SAML authentication with Azure Active Directory"
                              href="https://learn.microsoft.com/azure/active-directory/fundamentals/auth-saml"/>
                        <link title="How the Microsoft identity platform uses the SAML protocol"
                              href="https://learn.microsoft.com/azure/active-directory/develop/saml-protocol-reference"/>
                        <link title="Microsoft identity platform documentation"
                              href="https://learn.microsoft.com/azure/active-directory/develop"/>
                        <link title="Azure Active Directory documentation"
                              href="https://learn.microsoft.com/azure/active-directory"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">OpenSAML</technology-tag>
                </perform>
            </rule>
            <rule id="security-03600">
                <when>
                    <or>
                        <!-- Spring component declared in source code condition -->
                        <project>
                            <artifact groupId="org.springframework.security"
                                      artifactId="spring-security-core"/>
                        </project>
                        <!-- Spring Boot component declared in source code condition -->
                        <project>
                            <artifact groupId="org.springframework.boot"
                                      artifactId="spring-boot-starter-security"/>
                        </project>
                        <!-- Spring component in compiled application condition -->
                        <dependency groupId="org.springframework.security"
                                    artifactId="spring-security-core"/>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded framework - Spring Security"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds a Spring Security library. Ensure that the application is configured to access the identity provider.

                            Consider using Azure Active Directory as an identity provider.
                        </message>
                        <link title="Spring Security-related dependencies found in the project"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-app-service#identity-providers"/>
                        <link title="Azure Active Directory (Azure AD) identity provider for External Identities"
                              href="https://docs.microsoft.com/azure/active-directory/external-identities/azure-ad-account"/>
                        <link title="Spring Security"
                              href="https://docs.spring.io/spring-security/reference/index.html"/>
                        <link title="Spring Boot API: Authorization"
                              href="https://auth0.com/docs/quickstart/backend/java-spring-security5/01-authorization"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Spring Security</technology-tag>
                </perform>
            </rule>
            <rule id="security-03700">
                <when>
                    <file filename="{*}oauth2{*}.jar"/>
                </when>
                <perform>
                    <hint title="Embedded library - OAuth 2.0"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds an OAuth 2.0 library. For Spring Boot applications, please ensure that the application is configured to use Spring Security OAuth2.

                            The Microsoft identity platform uses OAuth 2.0 and other protocols to enable applications to provide a Single Sign-On experience.

                            By migrating your SSO implementation to Azure AD with OAuth 2.0, you leverage the capabilities of Azure AD for managing identities and enabling secure SSO across your applications.
                            Azure AD offers features like multi-factor authentication, conditional access policies, and seamless integration with various SaaS applications, providing a robust and scalable solution for identity and access management in the cloud.
                        </message>
                        <link title="OAuth 2.0 authentication with Azure Active Directory"
                              href="https://learn.microsoft.com/azure/active-directory/architecture/auth-oauth2"/>
                        <link title="OAuth 2.0 and OpenID Connect protocols on the Microsoft Identity Platform"
                              href="https://learn.microsoft.com/azure/active-directory/develop/v2-protocols"/>
                        <link title="Application types and OAuth2"
                              href="https://learn.microsoft.com/azure/active-directory/develop/v2-app-types"/>
                        <link title="Spring Cloud Security quickstart"
                              href="https://spring.io/projects/spring-cloud-security/"/>
                        <link title="Microsoft identity platform documentation"
                              href="https://learn.microsoft.com/azure/active-directory/develop"/>
                        <link title="Azure Active Directory documentation"
                              href="https://learn.microsoft.com/azure/active-directory"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">OAuth 2.0</technology-tag>
                </perform>
            </rule>
            <rule id="security-03800">
                <when>
                    <or>
                        <file filename="{*}openid4java{*}.jar"/>
                        <file filename="{*}pac4j-oidc{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded library - OpenID"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds an OpenID library. The Microsoft identity platform uses OpenID and other protocols to enable applications to provide a Single Sign-On experience.

                            By migrating your SSO implementation to Azure AD with OpenID, you leverage the capabilities of Azure AD for managing identities and enabling secure SSO across your applications.
                            Azure AD offers features like multi-factor authentication, conditional access policies, and seamless integration with various SaaS applications, providing a robust and scalable solution for identity and access management in the cloud.
                        </message>
                        <link title="OpenID Connect authentication with Azure Active Directory"
                              href="https://learn.microsoft.com/azure/active-directory/architecture/auth-oidc"/>
                        <link title="OAuth 2.0 and OpenID Connect protocols on the Microsoft Identity Platform"
                              href="https://learn.microsoft.com/azure/active-directory/develop/v2-protocols"/>
                        <link title="OpenID Connect on the Microsoft identity platform"
                              href="https://learn.microsoft.com/azure/active-directory/develop/v2-protocols-oidc"/>
                        <link title="Microsoft identity platform documentation"
                              href="https://learn.microsoft.com/azure/active-directory/develop"/>
                        <link title="Azure Active Directory documentation"
                              href="https://learn.microsoft.com/azure/active-directory"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">OpenID</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="clustering"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This is a simple ruleset for detecting usage of clustering technologies.
                This ruleset overrides the rules/rules-reviewed/technology-usage/clustering.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-appservice"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="clustering-00000">
                <when>
                    <xmlfile matches="/w:web-app/w:distributable">
                        <namespace prefix="w" uri="http://java.sun.com/xml/ns/javaee"/>
                    </xmlfile>
                </when>
                <perform>
                    <hint title="Distributed Environments found"
                          category-id="mandatory"
                          effort="5">
                        <message>
                            To migrate a distributed application that is clustered around several servers to Azure, you can follow these recommendations:

                            * **Configure multiple instances **: Deploy your Java application to Azure App Service and configure multiple instances within the same App Service Plan to create a cluster-like setup. Azure App Service automatically load-balances incoming requests across the available instances, ensuring scalability and high availability.

                            * **Manage sessions in a clustered environment**: Consider using an external session store such as Azure Cache for Redis. Configure your Java application to connect to the Azure Cache for Redis and to replicate sessions across the instances.
                        </message>
                        <link title="Azure Cache for Redis Documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Custom configuration settings for App Service Environments"
                              href="https://learn.microsoft.com/azure/app-service/environment/app-service-app-service-environment-custom-settings"/>
                        <link title="Identify session persistence mechanism"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-tomcat-to-azure-container-apps#identify-session-persistence-mechanism"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Clustering Web Session</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="database-xml"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset overrides the rules/rules-reviewed/technology-usage/database.windup.groovy ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <tag>database</tag>
        </metadata>
        <rules>
            <rule id="database-01500">
                <when>
                    <file filename="{*}mysql-connector{*}.jar"/>
                </when>
                <perform>
                    <hint title="MySQL database found" category-id="potential" effort="3">
                        <message>
                            To migrate a Java application that uses a MySQL database to Azure, you can follow these recommendations:

                            * Use a managed **Azure Database for MySQL**: For that create a managed MySQL database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate** the existing MySQL database: For that you can use the Azure Database Migration Service (DMS) to perform an online migration with minimal downtime.

                            * Update the application's **database connection** details: Modify the Java application's configuration to point to the newly provisioned Azure Database for MySQL. Update the connection string, hostname, port, username, and password information accordingly.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying MySQL database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the MySQL database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure Database for MySQL provides automated backups by default. You can configure the retention period for backups based on your requirements. You can also enable geo-redundant backups, if needed, to enhance data durability and availability.
                        </message>
                        <link title="Azure Database for MySQL documentation"
                              href="https://learn.microsoft.com/azure/mysql"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                        <link title="Backup and restore in Azure Database for MySQL"
                              href="https://learn.microsoft.com/azure/mysql/single-server/concepts-backup"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">MySQL Driver</technology-tag>
                </perform>
            </rule>
            <rule id="database-01700">
                <when>
                    <file filename="{*}postgresql{*}.jar"/>
                </when>
                <perform>
                    <hint title="PostgreSQL database found"
                          category-id="potential"
                          effort="3">
                        <message>
                            To migrate a Java application that uses a PostgreSQL database to Azure, you can follow these recommendations:

                            * Use a managed **Azure Database for PostgreSQL Flexible Server**: For that create a managed PostgreSQL Flexible Server database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate** the existing PostgreSQL database: For that you can use the Azure Database Migration Service (DMS) to perform an online migration with minimal downtime.

                            * Update the application's **database connection** details: Modify the Java application's configuration to point to the newly provisioned Azure Database for PostgreSQL. Update the connection string, hostname, port, username, and password information accordingly.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying PostgreSQL database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the PostgreSQL database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure Database for PostgreSQL provides automated backups by default. You can configure the retention period for backups based on your requirements. You can also enable geo-redundant backups, if needed, to enhance data durability and availability.
                        </message>
                        <link title="Azure PostgreSQL Flexible Server documentation"
                              href="https://learn.microsoft.com/azure/postgresql/flexible-server"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                        <link title="Backup and restore in Azure Database for PostgreSQL"
                              href="https://learn.microsoft.com/azure/postgresql/single-server/concepts-backup"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">PostgreSQL Driver</technology-tag>
                </perform>
            </rule>
            <rule id="database-01900">
                <when>
                    <or>
                        <file filename="sqljdbc{*}.jar"/>
                        <file filename="mssql-jdbc{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Microsoft SQL database found"
                          category-id="potential"
                          effort="3">
                        <message>
                            To migrate a Java application that uses a Microsoft SQL database to Azure, you can follow these recommendations:

                            * Use a managed **Azure SQL**: For that create a managed Azure SQL database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate** the existing Microsoft SQL database: For that you can use the Azure Database Migration Service (DMS) to perform an online migration with minimal downtime.

                            * Update the application's **database connection** details: Modify the Java application's configuration to point to the newly provisioned Azure SQL. Update the connection string, hostname, port, username, and password information accordingly.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying Azure SQL database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the Azure SQL database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure SQL provides automated backups by default. You can configure the retention period for backups based on your requirements. You can also enable geo-redundant backups, if needed, to enhance data durability and availability.
                        </message>
                        <link title="Azure SQL documentation"
                              href="https://learn.microsoft.com/azure/azure-sql"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                        <link title="Change automated backup settings for Azure SQL Database"
                              href="https://learn.microsoft.com/azure/azure-sql/database/automated-backups-change-settings"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Microsoft SQL Driver</technology-tag>
                </perform>
            </rule>
            <rule id="database-02200">
                <when>
                    <or>
                        <file filename="{*}cassandra{*}.jar"/>
                        <file filename="{*}hector{*}.jar"/>
                        <file filename="{*}astyanax{*}.jar"/>
                        <file filename="{*}phantom-dsl{*}.jar"/>
                        <file filename="{*}cql{*}.jar"/>
                        <file filename="{*}hecuba-client{*}.jar"/>
                        <file filename="{*}c-star-path{*}.jar"/>
                        <file filename="{*}scale7-pelops{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="Cassandra database found" category-id="potential" effort="3">
                        <message>
                            To migrate a Java application that uses a Cassandra database to Azure, you can follow these recommendations:

                            * Use an **Azure Managed Instance for Apache Cassandra**: Create an Azure Managed Instance for Apache Cassandra database and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate your Cassandra data**: Take a backup of your Cassandra data and restore the backup to Azure Managed Instance for Apache Cassandra. You can use Azure Database Migration Service to facilitate the backup and restore process.

                            * Update the application's **database connection** details: Modify your Java application's configuration to point to the new Azure Managed Instance for Apache Cassandra. Update the connection string and authentication details in your application code to ensure connectivity to the Azure Managed Instance for Apache Cassandra.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying Azure Managed Instance for Apache Cassandra database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the Azure Managed Instance for Apache Cassandra database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure Managed Instance for Apache Cassandra provides built-in backup functionality that allows you to create automated backups of your data. Enable backup for your account and configure the backup retention policy to specify how long the backups should be retained.
                        </message>
                        <link title="Azure Managed Instance for Apache Cassandra documentation"
                              href="https://learn.microsoft.com/azure/managed-instance-apache-cassandra"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Cassandra Client</technology-tag>
                </perform>
            </rule>
            <rule id="database-02500">
                <when>
                    <or>
                        <file filename="{*}mongodb{*}.jar"/>
                        <file filename="{*}casbah{*}.jar"/>
                        <file filename="{*}reactivemongo{*}.jar"/>
                        <file filename="{*}jongo{*}.jar"/>
                        <file filename="{*}gmongo{*}.jar"/>
                        <file filename="{*}rogue{*}.jar"/>
                    </or>
                </when>
                <perform>
                    <hint title="MongoDB database found" category-id="potential" effort="3">
                        <message>
                            To migrate a Java application that uses a MongoDB database to Azure, you can follow these recommendations:

                            * Use a managed **Azure Cosmos DB for MongoDB**: Create a managed Cosmos DB for MongoDB database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate your MongoDB data**: Take a backup of your MongoDB data and restore the backup to Azure Cosmos DB for MongoDB. You can use Azure Database Migration Service to facilitate the backup and restore process.

                            * Update the application's **database connection** details: Modify your Java application's configuration to point to the new Azure Cosmos DB for MongoDB instance. Update the connection string and authentication details in your application code to ensure connectivity to Azure Cosmos DB.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying Azure Cosmos DB for MongoDB database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the Azure Cosmos DB for MongoDB database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure Cosmos DB provides built-in backup functionality that allows you to create automated backups of your data. Enable backup for your Azure Cosmos DB account and configure the backup retention policy to specify how long the backups should be retained.
                        </message>
                        <link title="Azure Cosmos DB for MongoDB documentation"
                              href="https://learn.microsoft.com/azure/cosmos-db/mongodb"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">MongoDB Client</technology-tag>
                </perform>
            </rule>
            <rule id="database-03200">
                <when>
                    <file filename="{*}mariadb{*}.jar"/>
                </when>
                <perform>
                    <hint title="MariaDB database found" category-id="potential" effort="3">
                        <message>
                            To migrate a Java application that uses a MariaDB database to Azure, you can follow these recommendations:

                            * Use a managed **Azure Database for MariaDB**: For that create a managed MariaDB database in Azure and choose the appropriate pricing tier based on your application's requirements for performance, storage, and availability.

                            * **Migrate** the existing MariaDB database: For that you can use the Azure Database Migration Service (DMS) to perform an online migration with minimal downtime.

                            * Update the application's **database connection** details: Modify the Java application's configuration to point to the newly provisioned Azure Database for MariaDB. Update the connection string, hostname, port, username, and password information accordingly.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor to gain insights into the performance and health of your Java application and the underlying MariaDB database. Set up metrics, alerts, and log analytics to proactively identify and resolve issues.

                            * Implement **security** measures: Apply security best practices to protect your Java application and the MariaDB database. This includes implementing authentication and authorization mechanisms with passwordless connections and leveraging Microsoft Defender for Cloud for threat detection and vulnerability assessments.

                            * **Backup** your data: Azure Database for MariaDB provides automated backups by default. You can configure the retention period for backups based on your requirements. You can also enable geo-redundant backups, if needed, to enhance data durability and availability.
                        </message>
                        <link title="Azure Database for MariaDB documentation"
                              href="https://learn.microsoft.com/azure/mariadb"/>
                        <link title="Azure Database Migration Service documentation"
                              href="https://learn.microsoft.com/azure/dms"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                        <link title="Backup and restore in Azure Database for MariaDB"
                              href="https://learn.microsoft.com/azure/mariadb/howto-restore-server-portal"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">MariaDB Driver</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="connect-xml"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset overrides the rules/rules-reviewed/technology-usage/connect.windup.groovy ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <tag>connect</tag>
        </metadata>
        <rules>
            <rule id="connect-01500">
                <when>
                    <or>
                        <file filename="{*}activemq{*}"/>
                        <project>
                            <artifact groupId="org.springframework.boot"
                                      artifactId="spring-boot-starter-activemq"/>
                        </project>
                        <project>
                            <artifact groupId="org.apache.activemq" artifactId="{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="ActiveMQ found" category-id="potential" effort="3">
                        <message>
                            To migrate a Java application that uses ActiveMQ to Azure, you can follow these recommendations:

                            * Provision **Azure Service Bus**: Replace ActiveMQ with Azure Service Bus, a fully managed messaging service that offers reliable message queuing and publish/subscribe capabilities.

                            * Update the application's **messaging connection** details: Modify the Java application's configuration updating the connection information and message queues/topics.

                            * Configure Azure Service Bus **queues/topics**: Create appropriate queues or topics in Azure Service Bus to align with your application's messaging requirements. Configure access control and security settings as needed.

                            * Handle **message persistence**: ActiveMQ often relies on disk storage for message persistence. Azure Service Bus offers built-in message persistence, ensuring reliable message delivery. Ensure your application's messaging code handles message persistence appropriately.

                            * Enable **monitoring and diagnostics**: Utilize Azure Monitor and Microsoft Defender for Cloud to monitor and detect any potential security threats or anomalies in your Azure Service Bus environment. Enable diagnostics logging and set up alerts for suspicious activities.

                            * Apply **security** measures: Implement Azure Active Directory (Azure AD) authentication and authorization for accessing Azure Service Bus resources. Enable TLS encryption for communication between your Java application and Azure Service Bus. Enable passwordless connections for Azure services to improve security and reduce the risk of credential theft.
                        </message>
                        <link title="Spring Boot application using an Active MQ Broker"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#jms-message-brokers"/>
                        <link title="Azure Service Bus documentation"
                              href="https://learn.microsoft.com/azure/service-bus-messaging"/>
                        <link title="Migrate existing Java Message Service applications from Apache ActiveMQ to Azure Service Bus"
                              href="https://learn.microsoft.com/azure/service-bus-messaging/migrate-jms-activemq-to-servicebus"/>
                        <link title="Azure Monitor documentation"
                              href="https://learn.microsoft.com/azure/azure-monitor"/>
                        <link title="Passwordless connections for Azure services"
                              href="https://learn.microsoft.com/azure/developer/intro/passwordless-overview"/>
                        <link title="Microsoft Defender for Cloud"
                              href="https://learn.microsoft.com/azure/defender-for-cloud"/>
                        <link title="How to use the Spring Boot Starter for Azure Service Bus JMS"
                              href="https://docs.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-service-bus"/>
                        <link title="Azure Spring Boot Starter for Azure Service Bus JMS"
                              href="https://search.maven.org/artifact/com.azure.spring/azure-spring-boot-starter-servicebus-jms"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">ActiveMQ</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="3rd-party"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects embedded 3rd-party framework, which may be problematic when migrating an application to a cloud environment.
                This ruleset overrides the rules/rules-reviewed/technology-usage/3rd-party.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="3rd-party-05000">
                <when>
                    <or>
                        <file filename="{*}logstash{*}.jar"/>
                        <project>
                            <artifact groupId="{*}" artifactId="{*}logstash{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded library - Logstash"
                          category-id="potential"
                          effort="3">
                        <message>
                            The application embeds the Logstash framework. To migrate a Java application that uses LogStash/ELK Stack for log aggregation to Azure, you can follow this recommendation:

                            * Ensure your logging output is routed to the console and not to files.

                            * Configure the diagnostic setting to stream the console output to an Azure Event Hub.

                            * Use the LogStash EventHub plugin to ingest logged events into LogStash.
                        </message>
                        <link title="Ensure console logging and configure diagnostic settings"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#ensure-console-logging-and-configure-diagnostic-settings"/>
                        <link title="Azure Event Hub"
                              href="https://learn.microsoft.com/azure/event-hubs/event-hubs-about"/>
                        <link title="Logstash EventHub plugin"
                              href="https://github.com/logstash-plugins/logstash-input-azure_event_hubs"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Logstash</technology-tag>
                </perform>
            </rule>
            <rule id="3rd-party-20000">
                <when>
                    <or>
                        <file filename="{*}splunk{*}.jar"/>
                        <project>
                            <artifact groupId="{*}" artifactId="{*}splunk{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded library - Splunk"
                          category-id="potential"
                          effort="3">
                        <message>
                            The application embeds the Splunk framework. To migrate a Java application that uses Splunk for log aggregation to Azure, you can follow this recommendation:

                            * Ensure your logging output is routed to the console and not to files.

                            * Configure the diagnostic setting to stream the console output to Azure Blob Storage.

                            * Use the Splunk Add-on for Microsoft Cloud Services to ingest logged events into Splunk.
                        </message>
                        <link title="Ensure console logging and configure diagnostic settings"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#ensure-console-logging-and-configure-diagnostic-settings"/>
                        <link title="Azure Blob Storage"
                              href="https://learn.microsoft.com/azure/storage/blobs/"/>
                        <link title="Splunk Add-on for Microsoft Cloud Services"
                              href="https://splunkbase.splunk.com/app/3757"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Splunk</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="configuration-management"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                Identify configuration-management related technologies.
                This ruleset overrides the rules/rules-reviewed/technology-usage/configuration-management.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-xml,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="configuration-management-0100">
                <when>
                    <or>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-config-client"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-starter-config"/>
                        </project>
                        <dependency groupId="org.springframework.cloud"
                                    artifactId="spring-cloud-config-client"/>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded library - Spring Cloud Config"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds Spring Cloud Config.

                            If you are migrating to Azure Spring Apps, the connection info of Config Server will be injected automatically upon app start.
                            Find any explicit configurations of config server connection info:

                            If configured in **configuration files**: they will be ignored and overrided by Azure Spring Apps.

                            If configured in **command line parameters**, **Java system attribute**, **environment variable**: they need to be removed or you might experience conflicts and unexpected behavior.

                            Configure the config server after creating an Azure Spring Apps instance.
                        </message>
                        <link title="Prepare the Spring Cloud Config server"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#prepare-the-spring-cloud-config-server"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Spring Cloud Config</technology-tag>
                </perform>
            </rule>
            <rule id="configuration-management-0600">
                <when>
                    <or>
                        <file filename="{*}spring-cloud-vault{*}.jar"/>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-starter-vault-config"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-vault-config"/>
                        </project>
                        <dependency groupId="org.springframework.cloud"
                                    artifactId="spring-cloud-vault-config"/>
                        <filecontent filename="{*}.{extensions}" pattern="spring.cloud.vault"/>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded library - Spring Cloud Vault"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds Spring Cloud Vault.
                            To migrate a Java application that uses Spring Cloud Vault to store and access secrets to Azure, you can follow this recommendation:

                            * Identify the backing secret store (for example, HashiCorp Vault or CredHub).

                            * Identify all the secrets used by the application code.

                            * Migrate Spring Cloud Vault secrets to Azure KeyVault. You can inject secrets directly into applications through Spring by using the Azure KeyVault Spring Boot Starter.

                            * Note that Migration may require you to rename some secrets. Update your application code accordingly.
                        </message>
                        <link title="Load a secret from Azure Key Vault in a Spring Boot application"
                              href="https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-key-vault"/>
                        <link title="Azure Key Vault"
                              href="https://learn.microsoft.com/azure/key-vault/general/overview"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Spring Cloud Vault</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="embedded-framework"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset provides analysis of embedded frameworks.
                This ruleset overrides the rules/rules-reviewed/technology-usage/embedded-framework.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="embedded-framework-09000">
                <when>
                    <or>
                        <file filename="feign-{*}.jar"/>
                        <project>
                            <artifact groupId="com.netflix.feign" artifactId="{*}"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.cloud"
                                      artifactId="spring-cloud-starter-feign"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded framework - Feign"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds the Feign framework. If you are migrating to Azure Spring Apps, it is recommended to use Spring Cloud OpenFeign instead (Spring Cloud Feign has been deprecated).

                            When migrating to Azure Spring Apps, Eureka (Standard Tier) or Service Registry (Enterprise Tier) will be hosted for you. Spring Cloud OpenFeign will easily discover the service registry and invoke the services.
                        </message>
                        <link title="Migrate clients bypassing the service registry"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#identify-clients-that-bypass-the-service-registry"/>
                        <link title="Spring Cloud OpenFeign"
                              href="https://spring.io/projects/spring-cloud-openfeign/"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Feign</technology-tag>
                </perform>
            </rule>
            <rule id="embedded-framework-09100">
                <when>
                    <or>
                        <file filename="{*}zipkin{*}.jar"/>
                        <project>
                            <artifact groupId="org.springframework.boot"
                                      artifactId="spring-cloud-starter-zipkin"/>
                        </project>
                        <project>
                            <artifact groupId="io.zipkin{*}" artifactId="{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded framework - Zipkin"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds the Zipkin framework. To migrate a Java application that uses Zipkin to Azure, it is recommended to use Azure Monitor instead.

                            * **Identify Zipkin dependencies**: Identify the Zipkin dependencies in your application.

                            * **Replace with Azure Monitor**: Azure Monitor provides distributed tracing capabilities. Azure services such as Azure Spring Apps, Azure Kubernetes Service, Azure App Service support auto-instrumentation for Azure Monitor.
                        </message>
                        <link title="Azure Monitor"
                              href="https://learn.microsoft.com/azure/azure-monitor/"/>
                        <link title="Spring Boot to Azure - identify Zipkin dependencies"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?pivots=sc-standard-tier#identify-zipkin-dependencies"/>
                        <link title="Use Application Insights Java In-Process Agent in Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-application-insights"/>
                        <link title="Distributed Tracing"
                              href="https://learn.microsoft.com/azure/azure-monitor/app/distributed-trace-data"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Zipkin</technology-tag>
                </perform>
            </rule>
            <rule id="embedded-framework-09300">
                <when>
                    <or>
                        <file filename="{*}eureka-client{*}.jar"/>
                        <project>
                            <artifact groupId="{*}" artifactId="{*}eureka-client{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded framework - Eureka Client"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds the Eureka client. If you are migrating to Azure Spring Apps, the connection info of Eureka will be injected upon app start.

                            Find any explicit configurations of config server connection info:

                            If configured in **configuration files**: they will be ignored and overrided by Azure Spring Apps.

                            If configured in **command line parameters**, **Java system attribute**, **environment variable**: they need to be removed or you might experience conflicts and unexpected behavior.
                        </message>
                        <link title="Azure Spring Apps - Enable Service Registration"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-service-registration?pivots=programming-language-java"/>
                        <link title="Azure Spring Apps - Access Config Server and Service Registry"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-access-data-plane-azure-ad-rbac"/>
                        <link title="Restricted configurations"
                              href="http://aka.ms/spring-cloud-to-asa?pivots=sc-standard-tier#remove-restricted-configurations"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Eureka</technology-tag>
                </perform>
            </rule>
            <rule id="embedded-framework-09400">
                <when>
                    <or>
                        <file filename="{*}eureka-server{*}.jar"/>
                        <project>
                            <artifact groupId="{*}" artifactId="{*}eureka-server{*}"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Embedded framework - Eureka Server"
                          category-id="information"
                          effort="0">
                        <message>
                            The application embeds the Eureka server. If you are migrating to Azure Spring Apps, Eureka (Standard Tier) or Service Registry (Enterprise Tier) will be hosted for you.
                        </message>
                        <link title="Azure Spring Apps - Don't include the Spring Cloud registry"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-cloud-to-azure-spring-apps?toc=%2Fazure%2Fspring-apps%2Ftoc.json&amp;bc=%2Fazure%2Fspring-apps%2Fbreadcrumb%2Ftoc.json&amp;pivots=sc-standard-tier#create-an-azure-spring-apps-instance-and-apps"/>
                        <link title="Azure Spring Apps - Enable Service Registration"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-service-registration?pivots=programming-language-java"/>
                        <link title="Azure Spring Apps - Access Config Server and Service Registry"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-access-data-plane-azure-ad-rbac"/>
                        <link title="Restricted configurations"
                              href="http://aka.ms/spring-cloud-to-asa?pivots=sc-standard-tier#remove-restricted-configurations"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Eureka</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="web"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset provides analysis of Java web libraries.
                This ruleset overrides the rules/rules-reviewed/technology-usage/web.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="technology-usage-web-01700">
                <when>
                    <or>
                        <file filename="{*}swing{*}.jar"/>
                        <javaclass references="javax.swing.{*}">
                            <location>IMPORT</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="Java Swing usage" effort="3" category-id="potential">
                        <message>
                            The application uses Java Swing for the graphical user interface.
                            Java Swing requires the JRE on the remote device.

                            * **Containerize** the Java Swing application: Build the Docker image so that it packages the application and the JRE, and push it to Azure Container Registry (ACR). Then you can deploy the container to Azure using Azure Container Instances (ACI), Azure Container Apps (ACA) or Azure Kubernetes Service (AKS).

                            * **Leverage Azure Virtual Machines (VMs)**: Create a Windows or Linux-based Azure VM with the appropriate configuration for hosting your Java Swing application. For this, install the required Java Development Kit (JDK) and Java Swing runtime on the Azure VM.

                            * **Consider performance**: Java Swing applications require the GUI to be rendered, which may bring performance and scalability limitations. Also check the networking requirements when selecting the appropriate Azure service for your Java Swing application.
                        </message>
                        <link title="Azure Container Registry documentation"
                              href="https://learn.microsoft.com/azure/container-registry"/>
                        <link title="Azure Container Instances documentation"
                              href="https://learn.microsoft.com/azure/container-instances"/>
                        <link title="Azure Container Apps documentation"
                              href="https://learn.microsoft.com/azure/container-apps/overview"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Swing</technology-tag>
                </perform>
            </rule>
            <rule id="technology-usage-web-02300">
                <when>
                    <file filename="{*}javafx{*}.jar"/>
                </when>
                <perform>
                    <hint title="JavaFX usage" effort="3" category-id="potential">
                        <message>
                            The application uses JavaFX for the graphical user interface.
                            JavaFX requires the JRE on the remote device.

                            * **Containerize** the JavaFX application: Build the Docker image so that it packages the application and the JRE, and push it to Azure Container Registry (ACR). Then you can deploy the container to Azure using Azure Container Instances (ACI), Azure Container Apps (ACA) or Azure Kubernetes Service (AKS).

                            * **Leverage Azure Virtual Machines (VMs)**: Create a Windows or Linux-based Azure VM with the appropriate configuration for hosting your JavaFX application. For this, install the required Java Development Kit (JDK) and JavaFX runtime on the Azure VM.

                            * **Consider performance**: JavaFX applications require the GUI to be rendered, which may bring performance and scalability limitations. Also check the networking requirements when selecting the appropriate Azure service for your JavaFX application.
                        </message>
                        <link title="Azure Container Registry documentation"
                              href="https://learn.microsoft.com/azure/container-registry"/>
                        <link title="Azure Container Instances documentation"
                              href="https://learn.microsoft.com/azure/container-instances"/>
                        <link title="Azure Container Apps documentation"
                              href="https://learn.microsoft.com/azure/container-apps/overview"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">JavaFX</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="embedded-cache-libraries"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects embedded cache libraries, which may be problematic when migrating an application to a cloud environment.
                This ruleset overrides the rules/rules-reviewed/technology-usage/embedded-cache-libraries.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>cache</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="embedded-cache-libraries-01000">
                <when>
                    <file filename="{*}ehcache{*}.jar"/>
                </when>
                <perform>
                    <hint title="EHCache library" category-id="potential" effort="5">
                        <message>
                            The application uses EHCache. Azure does not have a managed service for EHCache. You either have to set up the EHCache distribution on Azure yourself, or you can take advantage of a managed Redis service if you are ready to migrate from EHCache to Redis. Azure Cache for Redis offers scalability, high availability, and monitoring capabilities. **Azure Cache for Redis** provides features like data persistence, automatic failover, and built-in support for Redis commands, allowing you to leverage the benefits of Redis caching in your application running on Azure.

                            * **Provision an Azure Cache for Redis**: Configure the cache size and other relevant settings based on your application's requirements.

                            * **Update your Java code**: Replace the EHCache code in your Java application with the Azure Cache for Redis client libraries or SDKs. Update the code that establishes a connection to the Redis cache and performs cache-related operations.

                            * **Connect to Azure Cache for Redis**: Update the connection details in your Java application to point to the Azure Cache for Redis instance. Use the connection information provided by Azure (hostname, port, access keys, etc.) to establish a connection from your application.
                        </message>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Caching guidance"
                              href="https://learn.microsoft.com/azure/architecture/best-practices/caching"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">EHCache</technology-tag>
                </perform>
            </rule>
            <rule id="embedded-cache-libraries-16000">
                <when>
                    <or>
                        <file filename="{*}redis{*}.jar"/>
                        <project>
                            <artifact groupId="org.springframework.boot"
                                      artifactId="spring-boot-starter-data-redis"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.data" artifactId="spring-data-redis"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.session"
                                      artifactId="spring-session-data-redis"/>
                        </project>
                        <project>
                            <artifact groupId="org.springframework.integration"
                                      artifactId="spring-integration-redis"/>
                        </project>
                    </or>
                </when>
                <perform>
                    <hint title="Redis Cache library" category-id="potential" effort="3">
                        <message>
                            The application uses a Redis cache. You can take advantage of a managed Redis service that offers scalability, high availability, and monitoring capabilities. **Azure Cache for Redis** provides features like data persistence, automatic failover, and built-in support for Redis commands, allowing you to leverage the benefits of Redis caching in your application running on Azure.

                            * **Provision an Azure Cache for Redis**: Configure the cache size and other relevant settings based on your application's requirements.

                            * **Update your Java code**: Replace the embedded Redis cache code in your Java application with the Azure Cache for Redis client libraries or SDKs. Update the code that establishes a connection to the Redis cache and performs cache-related operations.

                            * **Connect to Azure Cache for Redis**: Connect your app to Azure Cache for Redis on azure by **Service Connector**. Use the connection information provided by Azure (hostname, port, access keys, etc.) to create a connection from your application.
                        </message>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Caching guidance"
                              href="https://learn.microsoft.com/azure/architecture/best-practices/caching"/>
                        <link title="Connect Azure Cache for Redis to your application in Azure Spring Apps"
                              href="https://learn.microsoft.com/azure/spring-apps/how-to-bind-redis?tabs=Java%2CService-Connector"/>
                        <link title="Redis Cache found in the application"
                              href="https://learn.microsoft.com/azure/developer/java/migration/migrate-spring-boot-to-azure-spring-apps#identify-external-caches"/>
                        <link title="Spring Data Redis"
                              href="https://spring.io/projects/spring-data-redis/"/>
                        <link title="Azure Spring Cloud Starter Cache"
                              href="https://search.maven.org/artifact/com.azure.spring/azure-spring-cloud-starter-cache"/>
                    </hint>
                    <technology-tag level="INFORMATIONAL">Redis</technology-tag>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="os-specific"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This is a ruleset for Windows operating system specific rules while migrating to Linux operating system.
                It overrides the rules/rules-reviewed/os/windows/os-specific.windup.xml ruleset
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>ms-windows</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="os-specific-00001">
                <when>
                    <filecontent filename="{*}.{extensions}" pattern="{pattern}"/>
                </when>
                <perform>
                    <hint title="Windows file system path" effort="3" category-id="mandatory">
                        <message>
                            The application currently relies on a file system path that is Microsoft Windows platform dependent.
                            To ensure compatibility and portability in the Azure environment, it is recommended to replace the file system path with a Linux-style path.

                            * **Review file system** dependencies: Identify the areas within your application that rely on file system paths. This could include file uploads, file access, file system operations, or any other components that interact with the file system.

                            * **Replace Windows-style paths**: Modify the application code to replace Windows-style file system paths with Linux-style paths. Linux-style paths use forward slashes as directory separators instead of backslashes.

                            * Use **platform-independent file** handling: When performing file system operations, utilize platform-independent file handling methods and libraries. Java provides classes like `Path` and `File` from the `java.nio.file` package, which handle file operations in a platform-independent manner.

                            * **Test and validate**: Thoroughly test the modified application in a Linux-based environment to ensure that the changes to the file system paths do not introduce any issues. Verify that the application can access and manipulate files correctly using the Linux-style paths.
                        </message>
                        <link title="Working across Windows and Linux file systems"
                              href="https://learn.microsoft.com/windows/wsl/filesystems"/>
                        <link title="Access Linux filesystems in Windows and WSL 2"
                              href="https://devblogs.microsoft.com/commandline/access-linux-filesystems-in-windows-and-wsl-2"/>
                        <tag>ms-windows</tag>
                    </hint>
                </perform>
                <where param="extensions">
                    <matches pattern="(java|properties|jsp|jspf|tag|xml|txt)"/>
                </where>
                <where param="pattern">
                    <matches pattern="(\W|\s|^)([a-zA-Z]\:|\\\\(\w+\.?)+)([\\\/][^\n\t]+)+"/>
                </where>
            </rule>
            <rule id="os-specific-00002">
                <when>
                    <file filename="{*}.dll"/>
                </when>
                <perform>
                    <hint title="Dynamic-Link Library (DLL)"
                          effort="5"
                          category-id="mandatory">
                        <message>
                            The application currently relies on a Dynamic-Link Library (DLL) that is specific to Microsoft Windows.
                            To ensure compatibility and portability in the Azure environment, you have two options:

                            * **Replace with a Linux-style shared library**: Develop or find an equivalent Linux-style shared library and adapt the application code.

                            * Utilize **Azure service that supports Dynamic-Link Libraries**: Research Azure offerings that support Windows operating systems (such as Azure Virtual Machines) and refactor your application to utilize the DLL running on this service.
                        </message>
                        <tag>ms-windows</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="session"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects data storage in HTTP session objects, which may be problematic when migrating an application to a cloud environment.
                It overrids the rules in the default ruleset rules/rules-reviewed/cloud-readiness/session.windup.xml to detect the same issue in Azure cloud environments.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>clustering</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="session-00001">
                <when>
                    <or>
                        <javaclass references="javax.servlet.http.HttpSession.setAttribute({*})"/>
                        <javaclass references="javax.servlet.http.HttpSession.putValue({*})"/>
                    </or>
                </when>
                <perform>
                    <hint title="HTTP Session data storage"
                          effort="5"
                          category-id="potential">
                        <message>
                            When migrating an application that stores data in an HTTP Session to Azure, it's important to consider that the HTTP Session is not a suitable mechanism for maintaining state in a cloud environment due to scaling in and out as load changes.
                            Instead, you can leverage Azure Cache for Redis to achieve session management in a cloud-native way.

                            * Provide **Azure Cache for Redis**: Azure Cache for Redis is a fully managed, highly scalable, and distributed caching service. It allows you to store and manage session data in-memory, providing fast and efficient access.

                            * **Configure** Azure Cache for Redis: Configure the cache settings, such as cache size, eviction policies, and access control.

                            * **Update session management**: Modify your application's session management code to use Azure Cache for Redis. Replace the usage of HTTP Session objects with the appropriate Redis-based session management implementation.

                            * **Store and retrieve session data**: Use the Azure Cache for Redis client libraries or connectors within your application to store and retrieve session data. This ensures that session state is securely managed and accessible across multiple instances of your application.

                            * **Test and validate**: Test your application to ensure that session state is maintained correctly using Azure Cache for Redis. Verify that session data is stored and retrieved accurately across multiple instances of your application.
                        </message>
                        <link title="Azure Cache for Redis Documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Quickstart: Use Azure Cache for Redis in Java"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis/cache-java-get-started"/>
                        <tag>clustering</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="mail"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects the Java Mail API, which may be problematic when migrating an application to a cloud environment.
                It overrids rules/rules-reviewed/cloud-readiness/mail.windup.xml
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>mail</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="mail-00000">
                <when>
                    <or>
                        <javaclass references="javax.mail.{*}"/>
                        <javaclass references="com.sun.mail.{*}"/>
                        <javaclass references="org.simplejavamail.{*}"/>
                        <javaclass references="org.apache.commons.mail.{*}"/>
                    </or>
                </when>
                <perform>
                    <hint title="Java Mail API" effort="3" category-id="potential">
                        <message>
                            The application uses email APIs to send or receive emails.
                            In a cloud environment, mail systems should be considered backing services and treated like attached resources.
                            You can either use SMTP directly, or use Azure Communication Services Email and migrate the email functionality of your application to Azure.

                            * Using **Azure Communication Services**: Create an Azure Communication Services resource in your Azure subscription. This will provide you with the necessary capabilities to send emails. pdate your application's email sending code to use the Azure Communication Services Email SDK or REST API. This involves integrating the Azure Communication Services Email client libraries into your application and configuring the required settings, such as the sender's email address, recipient addresses, subject, and email content.

                            * Using **SMTP directly**: You can also use your own SMTP provider. In this case, check if port 25 is open in the App Service SKU.
                        </message>
                        <link title="Azure Communication Services documentation"
                              href="https://learn.microsoft.com/azure/communication-services"/>
                        <link title="Quickstart: How to send an email using Azure Communication Service"
                              href="https://learn.microsoft.com/azure/communication-services/quickstarts/email/send-email"/>
                        <link title="Troubleshoot outbound SMTP connectivity problems in Azure"
                              href="https://learn.microsoft.com/azure/virtual-network/troubleshoot-outbound-smtp-connectivity"/>
                        <tag>mail</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="local-storage"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects local storage usage, which is problematic when migrating an application to a cloud environment.
                This ruleset overrides the rules/rules-reviewed/cloud-readiness/local-storage.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>storage</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <!--
      This rules could be merged together but they need to be separated due to issue WINDUP-1324 [https://issues.jboss.org/projects/WINDUP/issues/WINDUP-1324]
      This is also the reason why many messages are pretty similar.
    -->
        <rules>
            <rule id="local-storage-00001">
                <when>
                    <or>
                        <javaclass references="java.io.{ioclass}{*}">
                            <location>CONSTRUCTOR_CALL</location>
                        </javaclass>
                        <javaclass references="java.util.zip.ZipFile{*}">
                            <location>CONSTRUCTOR_CALL</location>
                        </javaclass>
                        <javaclass references="java.io.File.createTempFile({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.nio.file.Paths.get({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="File system - Java IO"
                          effort="3"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                            An application running inside a container could lose access to a file in local storage.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                        <tag>storage</tag>
                    </hint>
                </perform>
                <where param="ioclass">
                    <matches pattern="(FileWriter|FileReader|PrintStream|File|PrintWriter|RandomAccessFile)"/>
                </where>
            </rule>
            <rule id="local-storage-00002">
                <when>
                    <javaclass references="java.net.{class}({*})" matchesSource="{*}file{*}">
                        <location>CONSTRUCTOR_CALL</location>
                    </javaclass>
                </when>
                <perform>
                    <hint title="File system - java.net.URL/URI"
                          effort="3"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                            An application running inside a container could lose access to a file in local storage.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                        <tag>storage</tag>
                    </hint>
                </perform>
                <where param="class">
                    <matches pattern="(URL|URI)"/>
                </where>
            </rule>
            <rule id="local-storage-00003">
                <when>
                    <filecontent pattern="{path1}" filename="{*}{extensions}"/>
                </when>
                <perform>
                    <hint title="File system - File path URL"
                          effort="3"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                            An application running inside a container could lose access to a file in local storage.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                        <tag>storage</tag>
                    </hint>
                </perform>
                <where param="path1">
                    <!-- absolute paths on windows -->
                    <!-- UPDATE TO REMOVE PATTERNS STARTING WITH java: AND classpath: -->
                    <matches pattern="(([:=(,\{])([ ])*([&#34;'])?([a-zA-Z]):)(?&lt;![\&lt;\\\/\d\w])([\\\/]\w+)+(\.\w+)?"/>
                </where>
                <where param="extensions">
                    <matches pattern="(\.java|\.properties|\.jsp|\.jspf|\.tag|[^pom]\.xml|\.txt)"/>
                </where>
            </rule>
            <rule id="local-storage-00004">
                <when>
                    <filecontent pattern="{path2}" filename="{*}.{extensions}"/>
                </when>
                <perform>
                    <hint title="File system - 'file://' scheme"
                          effort="3"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                            An application running inside a container could lose access to a file in local storage.

                            The following recommendations depend on the function of the file in local storage:

                            * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                            * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                            * **Caching**: Use Azure Cache for Redis as a cache backing service.

                            * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                        </message>
                        <link title="Azure Storage documentation"
                              href="https://learn.microsoft.com/azure/storage"/>
                        <link title="Azure Monitor Logs overview"
                              href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                        <link title="Azure Cache for Redis documentation"
                              href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                        <link title="Azure App Configuration documentation"
                              href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                        <tag>storage</tag>
                    </hint>
                </perform>
                <where param="path2">
                    <!-- URL with local path -->
                    <matches pattern="file://"/>
                </where>
                <where param="extensions">
                    <matches pattern="(\\.java|\\.properties|\\.jsp|\\.jspf|\\.tag|[^pom]\\.xml|\\.txt)"/>
                </where>
            </rule>
            <rule id="local-storage-00005">
                <when>
                    <or>
                        <javaclass references="java.nio.channels.AsynchronousFileChannel{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="java.nio.channels.FileChannel{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="java.nio.channels.FileLock{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="java.nio.file.{*}">
                            <location>IMPORT</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <iteration>
                        <hint title="File system - Java NIO"
                              effort="3"
                              category-id="cloud-mandatory">
                            <message>
                                When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                                An application running inside a container could lose access to a file in local storage.

                                The following recommendations depend on the function of the file in local storage:

                                * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                                * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                                * **Caching**: Use Azure Cache for Redis as a cache backing service.

                                * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                            </message>
                            <link title="Azure Storage documentation"
                                  href="https://learn.microsoft.com/azure/storage"/>
                            <link title="Azure Monitor Logs overview"
                                  href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                            <link title="Azure Cache for Redis documentation"
                                  href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                            <link title="Azure App Configuration documentation"
                                  href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                            <tag>storage</tag>
                        </hint>
                    </iteration>
                </perform>
            </rule>
            <rule id="local-storage-00006">
                <when>
                    <or>
                        <javaclass references="org.apache.commons.io.input.{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="org.apache.commons.io.output.{*}">
                            <location>IMPORT</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <iteration>
                        <hint title="Apache Commons I/O" effort="3" category-id="cloud-mandatory">
                            <message>
                                When migrating an application that relies on the file system to Azure, it's important to consider the limitations of local storage in a cloud environment.
                                An application running inside a container could lose access to a file in local storage.

                                The following recommendations depend on the function of the file in local storage:

                                * **Reading/writing files**: Use Azure Storage services for object, block, and file storage to meet your data's highest demands.

                                * **Logging**: Log to standard output and use Azure Monitor to collect and analyze the logs.

                                * **Caching**: Use Azure Cache for Redis as a cache backing service.

                                * **Configuration**: Store configuration in Azure App Configuration instead of using the file system. Also store configuration settings in environment variables so that they can be updated without code changes.
                            </message>
                            <link title="Azure Storage documentation"
                                  href="https://learn.microsoft.com/azure/storage"/>
                            <link title="Azure Monitor Logs overview"
                                  href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                            <link title="Azure Cache for Redis documentation"
                                  href="https://learn.microsoft.com/azure/azure-cache-for-redis"/>
                            <link title="Azure App Configuration documentation"
                                  href="https://learn.microsoft.com/azure/azure-app-configuration"/>
                            <tag>storage</tag>
                        </hint>
                    </iteration>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="jni-native-code"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects Java Native Interface (JNI) and Java Native Access (JNA) code, which may be problematic when migrating an application to a cloud environment.
                This ruleset overrides the rules/rules-reviewed/cloud-readiness/jni-native-code.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>jni</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="jni-native-code-00000">
                <when>
                    <or>
                        <javaclass references="java.lang.System.load({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.System.loadLibrary({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.System.mapLibraryName({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.Runtime.load({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="java.lang.Runtime.loadLibrary({*})">
                            <location>METHOD_CALL</location>
                        </javaclass>
                        <javaclass references="com.sun.jna.{*}">
                            <location>CONSTRUCTOR_CALL</location>
                            <location>IMPORT</location>
                            <location>INHERITANCE</location>
                            <location>METHOD_CALL</location>
                            <location>VARIABLE_DECLARATION</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="Java native libraries (JNI, JNA)"
                          effort="7"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that uses Java native libraries (JNI, JNA) to Azure, it's important to consider that Java native libraries might not run in a cloud or container environment.
                            Instead, you can refactor your application to use cloud-compatible alternatives or managed services.

                            * **Identify native library dependencies**: Review all native libraries used in your application and review the purpose of each library.

                            * **Evaluate and use cloud-compatible alternatives**: For each native library, look for alternative libraries or services that provide similar functionality and are compatible with cloud environments. Replace instances of JNI or JNA usage with the chosen cloud-compatible alternatives.

                            * **Leverage Azure managed services**: Evaluate the use of Azure-managed services to replace certain native library functionalities. For example, if your application uses JNI or JNA for file operations, consider using Azure Storage for cloud-native storage solutions. If your application uses JNI or JNA to connect and interact with a local SQL database, consider replacing it with Azure Database for MySQL. This could eliminate the need for native code in your application.

                            * **Test and validate**: Thoroughly test the updated application to ensure it works correctly with the new libraries or services. Perform functional, performance, and stress tests to validate that the application meets its requirements and can handle the expected workload.
                        </message>
                        <tag>jni</tag>
                    </hint>
                </perform>
            </rule>
            <rule id="jni-native-code-00001">
                <when>
                    <or>
                        <javaclass references="java.lang.Process">
                            <location>CONSTRUCTOR_CALL</location>
                            <location>IMPORT</location>
                            <location>INHERITANCE</location>
                            <location>VARIABLE_DECLARATION</location>
                        </javaclass>
                        <javaclass references="java.lang.ProcessBuilder">
                            <location>CONSTRUCTOR_CALL</location>
                            <location>IMPORT</location>
                            <location>INHERITANCE</location>
                            <location>VARIABLE_DECLARATION</location>
                        </javaclass>
                        <javaclass references="java.lang.ProcessHandle">
                            <location>CONSTRUCTOR_CALL</location>
                            <location>IMPORT</location>
                            <location>INHERITANCE</location>
                            <location>VARIABLE_DECLARATION</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <hint title="Java Native Processes"
                          effort="7"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that uses native processes to Azure, it's important to consider that native processes might not run in a cloud or container environment. Instead, you can refactor your application to use cloud-compatible alternatives or managed services.

                            * **Identify native process dependencies**: Review all native processes used in your application and understand the purpose of each process.

                            * **Evaluate and use cloud-compatible alternatives**: For each native process, look for alternative libraries, services, or APIs that provide similar functionality and are compatible with cloud environments. Replace instances of native process usage with the chosen cloud-compatible alternatives.

                            * **Leverage Azure managed services**: Evaluate the use of Azure-managed services to replace certain native process functionalities.

                            * **Test and validate**: Thoroughly test the updated application to ensure it works correctly with the new libraries or services. Perform functional, performance, and stress tests to validate that the application meets its requirements and can handle the expected workload.
                        </message>
                        <tag>jni</tag>
                    </hint>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="java-rmi"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects the Java Remote Method Invocation (RMI), which may be problematic when migrating an application to a cloud environment.
                This ruleset overrides the rules/rules-reviewed/cloud-readiness/java-rmi.windup.xml ruleset.
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,2.7.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,2.7.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>rmi</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="java-rmi-00000">
                <when>
                    <javaclass references="java.rmi.Remote">
                        <location>INHERITANCE</location>
                    </javaclass>
                </when>
                <perform>
                    <hint title="Java Remote Method Invocation (RMI) service"
                          effort="7"
                          category-id="cloud-mandatory">
                        <message>
                            When migrating an application that uses Java Remote Method Invocation (RMI) service to Azure, it's crucial to consider that RMI is a tightly coupled service and tight coupling is not suitable in a cloud environment because of scalability problems.

                            Here are some recommendations for migrating such an application to Azure:

                            * **Use HTTP-based communication**: Replace RMI with a more loosely coupled communication approach, such as HTTP or HTTPS, in combination with an architectural pattern like RESTful APIs.

                            * **Leverage Azure managed services**: You can also consider using Azure managed services to replace RMI. For real-time, bidirectional communication that require low-latency, consider integrating Azure SignalR Service. It simplifies real-time web functionality and supports WebSocket communication. For asynchronous, message-based communication, consider using Azure messaging services like Azure Service Bus or Azure Event Hubs.
                        </message>
                        <link title="Twelve-factor app - Backing services"
                              href="https://12factor.net/backing-services"/>
                        <link title="Azure SignalR Service"
                              href="https://learn.microsoft.com/azure/azure-signalr/signalr-overview"/>
                        <link title="Azure Service Bus"
                              href="https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview"/>
                        <link title="Azure Event Hubs"
                              href="https://docs.microsoft.com/azure/event-hubs/event-hubs-about"/>
                        <tag>rmi</tag>
                        <tag>cloud-readiness</tag>
                    </hint>
                </perform>
            </rule>
            <rule id="java-rmi-00001">
                <when>
                    <javaclass references="java.rmi.{*}"/>
                </when>
                <perform>
                    <iteration>
                        <when>
                            <not>
                                <has-classification title="Java Remote Method Invocation (RMI) service"/>
                            </not>
                        </when>
                        <perform>
                            <classification issue-display-mode="all"
                                            title="Java Remote Method Invocation (RMI) API"
                                            effort="7"
                                            category-id="cloud-mandatory">
                                <description>
                                    When migrating an application that uses Java Remote Method Invocation (RMI) API to Azure, it's crucial to consider that RMI is a tightly coupled service and tight coupling is not suitable in a cloud environment because of scalability problems.

                                    Here are some recommendations for migrating such an application to Azure:

                                    * **Use HTTP-based communication**: Replace RMI with a more loosely coupled communication approach, such as HTTP or HTTPS, in combination with an architectural pattern like RESTful APIs.

                                    * **Leverage Azure managed services**: You can also consider using Azure managed services to replace RMI. For real-time, bidirectional communication that require low-latency, consider integrating Azure SignalR Service. It simplifies real-time web functionality and supports WebSocket communication. For asynchronous, message-based communication, consider using Azure messaging services like Azure Service Bus or Azure Event Hubs.
                                </description>
                                <link title="Twelve-factor app - Backing services"
                                      href="https://12factor.net/backing-services"/>
                                <link title="Azure SignalR Service"
                                      href="https://learn.microsoft.com/azure/azure-signalr/signalr-overview"/>
                                <link title="Azure Service Bus"
                                      href="https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview"/>
                                <link title="Azure Event Hubs"
                                      href="https://docs.microsoft.com/azure/event-hubs/event-hubs-about"/>
                                <tag>rmi</tag>
                            </classification>
                        </perform>
                    </iteration>
                </perform>
            </rule>
        </rules>
    </ruleset>
    <ruleset xmlns="http://windup.jboss.org/schema/jboss-ruleset"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             id="logging"
             xsi:schemaLocation="http://windup.jboss.org/schema/jboss-ruleset http://windup.jboss.org/schema/jboss-ruleset/windup-jboss-ruleset.xsd">
        <metadata>
            <description>
                This ruleset detects logging configurations that may be problematic when migrating an application to a cloud environment.
                It overrids the ruleset rules/rules-reviewed/cloud-readiness/logging.windup.xml
            </description>
            <dependencies>
                <addon id="org.jboss.windup.rules,windup-rules-javaee,3.0.0.Final"/>
                <addon id="org.jboss.windup.rules,windup-rules-java,3.0.0.Final"/>
            </dependencies>
            <targetTechnology id="azure-spring-apps"/>
            <targetTechnology id="azure-appservice"/>
            <targetTechnology id="azure-aks"/>
            <targetTechnology id="azure-container-apps"/>
            <tag>logging</tag>
            <overrideRules>true</overrideRules>
        </metadata>
        <rules>
            <rule id="logging-0000">
                <when>
                    <or>
                        <filecontent filename="log{back,4j}{*}.{extension}" pattern="{filePattern}"/>
                        <javaclass references="org.apache.{*}log4j.{*}FileAppender{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="java.util.logging.FileHandler{*}">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="ch.qos.logback.core.FileAppender">
                            <location>IMPORT</location>
                        </javaclass>
                        <javaclass references="org.pmw.tinylog.writers.FileWriter">
                            <location>IMPORT</location>
                        </javaclass>
                    </or>
                </when>
                <perform>
                    <iteration>
                        <when>
                            <not>
                                <has-hint/>
                            </not>
                        </when>
                        <perform>
                            <hint title="Don't log to file system"
                                  effort="1"
                                  category-id="cloud-mandatory">
                                <message>
                                    Logging to the file system is not recommended when running applications in the cloud.
                                    Instead, use Azure Monitor for efficient and scalable logging.

                                    * Integrate with **Azure Monitor**: Configure your application to send logs to Azure Monitor. Azure Monitor provides a centralized platform for collecting, analyzing, and visualizing log data from various sources.

                                    * Use **Azure Monitor Logging**: Utilize the Azure Monitor Logs feature, which enables you to query and analyze log data using the Kusto Query Language (KQL). KQL provides powerful querying capabilities to extract insights and perform advanced log analysis.

                                    * Leverage **Log Analytics** workspaces: Create a Log Analytics workspace within Azure Monitor to store and analyze your log data effectively. Configure your application to send logs to the designated workspace, enabling centralized log storage and analysis.

                                    * Utilize **KQL** for log analysis: Familiarize yourself with the Kusto Query Language (KQL) to write powerful queries for log analysis in Azure Monitor. KQL provides a flexible and efficient way to extract insights, perform aggregations, and create visualizations from your log data.
                                </message>
                                <link title="Azure Monitor Logs overview"
                                      href="https://learn.microsoft.com/azure/azure-monitor/logs/data-platform-logs"/>
                                <link title="Log queries in Azure Monitor"
                                      href="https://learn.microsoft.com/azure/azure-monitor/logs/log-query-overview"/>
                                <link title="Enable diagnostics logging for apps in Azure App Service"
                                      href="https://learn.microsoft.com/azure/app-service/troubleshoot-diagnostic-logs"/>
                                <link title="Log Analytics tutorial"
                                      href="https://learn.microsoft.com/azure/azure-monitor/logs/log-analytics-tutorial"/>
                                <tag>logging</tag>
                            </hint>
                            <technology-tag level="INFORMATIONAL">Logging to file system</technology-tag>
                        </perform>
                    </iteration>
                </perform>
                <where param="filePattern">
                    <matches pattern="(?i)((Daily)?Rolling)?FileAppender|type\s*=\s*((Daily)?Rolling)?File|&lt;\/((Daily)?Rolling)?File&gt;"/>
                </where>
                <where param="extension">
                    <matches pattern="(xml|properties)"/>
                </where>
            </rule>
        </rules>
    </ruleset>
</root>
